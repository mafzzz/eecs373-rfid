
barcode_test:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000229c  20000000  20000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000528  2000229c  2000229c  0000a29c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000006c  200027c4  200027c4  0000a7c4  2**2
                  ALLOC
  3 .stack        00003000  20002830  20002830  0000a7c4  2**0
                  ALLOC
  4 .comment      0000012d  00000000  00000000  0000a7c4  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 000000e0  00000000  00000000  0000a8f1  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 0000039f  00000000  00000000  0000a9d1  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002cc7  00000000  00000000  0000ad70  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000755  00000000  00000000  0000da37  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000140d  00000000  00000000  0000e18c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  0000080c  00000000  00000000  0000f59c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000017bf  00000000  00000000  0000fda8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000008ff  00000000  00000000  00011567  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macinfo 0001f375  00000000  00000000  00011e66  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .ARM.attributes 00000025  00000000  00000000  000311db  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

20000000 <__text_start>:
20000000:	20010000 	.word	0x20010000
20000004:	20000299 	.word	0x20000299
20000008:	200002f9 	.word	0x200002f9
2000000c:	200002fb 	.word	0x200002fb
20000010:	200002fd 	.word	0x200002fd
20000014:	200002ff 	.word	0x200002ff
20000018:	20000301 	.word	0x20000301
	...
2000002c:	20000303 	.word	0x20000303
20000030:	20000305 	.word	0x20000305
20000034:	00000000 	.word	0x00000000
20000038:	20000307 	.word	0x20000307
2000003c:	20000309 	.word	0x20000309
20000040:	2000030b 	.word	0x2000030b
20000044:	2000030d 	.word	0x2000030d
20000048:	2000030f 	.word	0x2000030f
2000004c:	20000311 	.word	0x20000311
20000050:	20000313 	.word	0x20000313
20000054:	20000315 	.word	0x20000315
20000058:	20000317 	.word	0x20000317
2000005c:	20000319 	.word	0x20000319
20000060:	2000031b 	.word	0x2000031b
20000064:	2000031d 	.word	0x2000031d
20000068:	2000031f 	.word	0x2000031f
2000006c:	20000321 	.word	0x20000321
20000070:	20000323 	.word	0x20000323
20000074:	20000325 	.word	0x20000325
20000078:	20000327 	.word	0x20000327
2000007c:	20000329 	.word	0x20000329
20000080:	2000032b 	.word	0x2000032b
20000084:	2000032d 	.word	0x2000032d
20000088:	2000032f 	.word	0x2000032f
2000008c:	20000331 	.word	0x20000331
20000090:	20000333 	.word	0x20000333
20000094:	20000335 	.word	0x20000335
20000098:	20000337 	.word	0x20000337
2000009c:	20000339 	.word	0x20000339
200000a0:	2000033b 	.word	0x2000033b
	...
200000bc:	2000033d 	.word	0x2000033d
200000c0:	20000521 	.word	0x20000521
200000c4:	20000341 	.word	0x20000341
200000c8:	20000343 	.word	0x20000343
200000cc:	20000345 	.word	0x20000345
200000d0:	20000347 	.word	0x20000347
200000d4:	20000349 	.word	0x20000349
200000d8:	2000034b 	.word	0x2000034b
200000dc:	2000034d 	.word	0x2000034d
200000e0:	2000034f 	.word	0x2000034f
200000e4:	20000351 	.word	0x20000351
200000e8:	20000353 	.word	0x20000353
200000ec:	20000355 	.word	0x20000355
200000f0:	20000357 	.word	0x20000357
200000f4:	20000359 	.word	0x20000359
200000f8:	2000035b 	.word	0x2000035b
200000fc:	2000035d 	.word	0x2000035d
20000100:	2000035f 	.word	0x2000035f
20000104:	20000361 	.word	0x20000361
20000108:	20000363 	.word	0x20000363
2000010c:	20000365 	.word	0x20000365
20000110:	20000367 	.word	0x20000367
20000114:	20000369 	.word	0x20000369
20000118:	2000036b 	.word	0x2000036b
2000011c:	2000036d 	.word	0x2000036d
20000120:	2000036f 	.word	0x2000036f
20000124:	20000371 	.word	0x20000371
20000128:	20000373 	.word	0x20000373
2000012c:	20000375 	.word	0x20000375
20000130:	20000377 	.word	0x20000377
20000134:	20000379 	.word	0x20000379
20000138:	2000037b 	.word	0x2000037b
2000013c:	2000037d 	.word	0x2000037d
20000140:	2000037f 	.word	0x2000037f
20000144:	20000381 	.word	0x20000381
20000148:	20000383 	.word	0x20000383
2000014c:	20000385 	.word	0x20000385
20000150:	20000387 	.word	0x20000387
20000154:	20000389 	.word	0x20000389
20000158:	2000038b 	.word	0x2000038b
2000015c:	2000038d 	.word	0x2000038d
20000160:	2000038f 	.word	0x2000038f
20000164:	20000391 	.word	0x20000391
20000168:	20000393 	.word	0x20000393
2000016c:	20000395 	.word	0x20000395
20000170:	20000397 	.word	0x20000397
20000174:	20000399 	.word	0x20000399
20000178:	2000039b 	.word	0x2000039b
2000017c:	2000039d 	.word	0x2000039d
20000180:	2000039f 	.word	0x2000039f
20000184:	200003a1 	.word	0x200003a1
20000188:	200003a3 	.word	0x200003a3
2000018c:	200003a5 	.word	0x200003a5
20000190:	200003a7 	.word	0x200003a7
20000194:	200003a9 	.word	0x200003a9
20000198:	200003ab 	.word	0x200003ab
2000019c:	200003ad 	.word	0x200003ad
200001a0:	200003af 	.word	0x200003af
200001a4:	200003b1 	.word	0x200003b1
200001a8:	200003b3 	.word	0x200003b3
200001ac:	200003b5 	.word	0x200003b5
200001b0:	200003b7 	.word	0x200003b7
200001b4:	200003b9 	.word	0x200003b9
200001b8:	200003bb 	.word	0x200003bb
200001bc:	200003bd 	.word	0x200003bd
200001c0:	200003bf 	.word	0x200003bf
200001c4:	200003c1 	.word	0x200003c1
200001c8:	200003c3 	.word	0x200003c3
200001cc:	200003c5 	.word	0x200003c5
200001d0:	200003c7 	.word	0x200003c7
200001d4:	200003c9 	.word	0x200003c9
200001d8:	200003cb 	.word	0x200003cb
200001dc:	200003cd 	.word	0x200003cd
200001e0:	200003cf 	.word	0x200003cf
200001e4:	200003d1 	.word	0x200003d1
200001e8:	200003d3 	.word	0x200003d3
200001ec:	200003d5 	.word	0x200003d5
200001f0:	200003d7 	.word	0x200003d7
200001f4:	200003d9 	.word	0x200003d9
200001f8:	200003db 	.word	0x200003db
200001fc:	200003dd 	.word	0x200003dd
20000200:	200003df 	.word	0x200003df
20000204:	200003e1 	.word	0x200003e1
20000208:	200003e3 	.word	0x200003e3
2000020c:	200003e5 	.word	0x200003e5
20000210:	200003e7 	.word	0x200003e7
20000214:	200003e9 	.word	0x200003e9
20000218:	200003eb 	.word	0x200003eb
2000021c:	200003ed 	.word	0x200003ed
20000220:	200003ef 	.word	0x200003ef
20000224:	200003f1 	.word	0x200003f1
20000228:	200003f3 	.word	0x200003f3
2000022c:	200003f5 	.word	0x200003f5
20000230:	200003f7 	.word	0x200003f7
20000234:	200003f9 	.word	0x200003f9
20000238:	200003fb 	.word	0x200003fb
2000023c:	200003fd 	.word	0x200003fd
20000240:	200003ff 	.word	0x200003ff
20000244:	20000401 	.word	0x20000401
20000248:	20000403 	.word	0x20000403
2000024c:	20000405 	.word	0x20000405
20000250:	20000407 	.word	0x20000407
20000254:	20000409 	.word	0x20000409
20000258:	2000040b 	.word	0x2000040b
2000025c:	2000040d 	.word	0x2000040d
20000260:	2000040f 	.word	0x2000040f
20000264:	20000411 	.word	0x20000411
20000268:	20000413 	.word	0x20000413
2000026c:	20000415 	.word	0x20000415
20000270:	20000417 	.word	0x20000417
20000274:	20000419 	.word	0x20000419
20000278:	2000041b 	.word	0x2000041b
2000027c:	2000041d 	.word	0x2000041d
20000280:	2000041f 	.word	0x2000041f
20000284:	20000421 	.word	0x20000421
20000288:	20000423 	.word	0x20000423
2000028c:	20000425 	.word	0x20000425
20000290:	20000427 	.word	0x20000427
20000294:	20000429 	.word	0x20000429

20000298 <Reset_Handler>:
20000298:	4864      	ldr	r0, [pc, #400]	; (2000042c <ACE_PPE_Flag31_IRQHandler+0x4>)
2000029a:	4780      	blx	r0
2000029c:	4864      	ldr	r0, [pc, #400]	; (20000430 <ACE_PPE_Flag31_IRQHandler+0x8>)
2000029e:	2800      	cmp	r0, #0
200002a0:	d10b      	bne.n	200002ba <copy_data>
200002a2:	4864      	ldr	r0, [pc, #400]	; (20000434 <ACE_PPE_Flag31_IRQHandler+0xc>)
200002a4:	4964      	ldr	r1, [pc, #400]	; (20000438 <ACE_PPE_Flag31_IRQHandler+0x10>)
200002a6:	4a65      	ldr	r2, [pc, #404]	; (2000043c <ACE_PPE_Flag31_IRQHandler+0x14>)
200002a8:	4288      	cmp	r0, r1
200002aa:	d006      	beq.n	200002ba <copy_data>

200002ac <copy_code_loop>:
200002ac:	4291      	cmp	r1, r2
200002ae:	bf1c      	itt	ne
200002b0:	f850 3b04 	ldrne.w	r3, [r0], #4
200002b4:	f841 3b04 	strne.w	r3, [r1], #4
200002b8:	d1f8      	bne.n	200002ac <copy_code_loop>

200002ba <copy_data>:
200002ba:	4861      	ldr	r0, [pc, #388]	; (20000440 <ACE_PPE_Flag31_IRQHandler+0x18>)
200002bc:	4961      	ldr	r1, [pc, #388]	; (20000444 <ACE_PPE_Flag31_IRQHandler+0x1c>)
200002be:	4a62      	ldr	r2, [pc, #392]	; (20000448 <ACE_PPE_Flag31_IRQHandler+0x20>)
200002c0:	4288      	cmp	r0, r1
200002c2:	d006      	beq.n	200002d2 <clear_bss>

200002c4 <copy_data_loop>:
200002c4:	4291      	cmp	r1, r2
200002c6:	bf1c      	itt	ne
200002c8:	f850 3b04 	ldrne.w	r3, [r0], #4
200002cc:	f841 3b04 	strne.w	r3, [r1], #4
200002d0:	d1f8      	bne.n	200002c4 <copy_data_loop>

200002d2 <clear_bss>:
200002d2:	485e      	ldr	r0, [pc, #376]	; (2000044c <ACE_PPE_Flag31_IRQHandler+0x24>)
200002d4:	495e      	ldr	r1, [pc, #376]	; (20000450 <ACE_PPE_Flag31_IRQHandler+0x28>)
200002d6:	4a5f      	ldr	r2, [pc, #380]	; (20000454 <ACE_PPE_Flag31_IRQHandler+0x2c>)

200002d8 <clear_bss_loop>:
200002d8:	4291      	cmp	r1, r2
200002da:	bf18      	it	ne
200002dc:	f841 0b04 	strne.w	r0, [r1], #4
200002e0:	d1fa      	bne.n	200002d8 <clear_bss_loop>

200002e2 <call_glob_ctor>:
200002e2:	485d      	ldr	r0, [pc, #372]	; (20000458 <ACE_PPE_Flag31_IRQHandler+0x30>)
200002e4:	f20f 0e03 	addw	lr, pc, #3
200002e8:	4700      	bx	r0

200002ea <branch_to_main>:
200002ea:	f04f 0000 	mov.w	r0, #0
200002ee:	f04f 0100 	mov.w	r1, #0
200002f2:	f8df f168 	ldr.w	pc, [pc, #360]	; 2000045c <ACE_PPE_Flag31_IRQHandler+0x34>

200002f6 <ExitLoop>:
200002f6:	e7fe      	b.n	200002f6 <ExitLoop>

200002f8 <NMI_Handler>:
200002f8:	e7fe      	b.n	200002f8 <NMI_Handler>

200002fa <HardFault_Handler>:
200002fa:	e7fe      	b.n	200002fa <HardFault_Handler>

200002fc <MemManage_Handler>:
200002fc:	e7fe      	b.n	200002fc <MemManage_Handler>

200002fe <BusFault_Handler>:
200002fe:	e7fe      	b.n	200002fe <BusFault_Handler>

20000300 <UsageFault_Handler>:
20000300:	e7fe      	b.n	20000300 <UsageFault_Handler>

20000302 <SVC_Handler>:
20000302:	e7fe      	b.n	20000302 <SVC_Handler>

20000304 <DebugMon_Handler>:
20000304:	e7fe      	b.n	20000304 <DebugMon_Handler>

20000306 <PendSV_Handler>:
20000306:	e7fe      	b.n	20000306 <PendSV_Handler>

20000308 <SysTick_Handler>:
20000308:	e7fe      	b.n	20000308 <SysTick_Handler>

2000030a <WdogWakeup_IRQHandler>:
2000030a:	e7fe      	b.n	2000030a <WdogWakeup_IRQHandler>

2000030c <BrownOut_1_5V_IRQHandler>:
2000030c:	e7fe      	b.n	2000030c <BrownOut_1_5V_IRQHandler>

2000030e <BrownOut_3_3V_IRQHandler>:
2000030e:	e7fe      	b.n	2000030e <BrownOut_3_3V_IRQHandler>

20000310 <RTC_Match_IRQHandler>:
20000310:	e7fe      	b.n	20000310 <RTC_Match_IRQHandler>

20000312 <RTCIF_Pub_IRQHandler>:
20000312:	e7fe      	b.n	20000312 <RTCIF_Pub_IRQHandler>

20000314 <EthernetMAC_IRQHandler>:
20000314:	e7fe      	b.n	20000314 <EthernetMAC_IRQHandler>

20000316 <IAP_IRQHandler>:
20000316:	e7fe      	b.n	20000316 <IAP_IRQHandler>

20000318 <ENVM0_IRQHandler>:
20000318:	e7fe      	b.n	20000318 <ENVM0_IRQHandler>

2000031a <ENVM1_IRQHandler>:
2000031a:	e7fe      	b.n	2000031a <ENVM1_IRQHandler>

2000031c <DMA_IRQHandler>:
2000031c:	e7fe      	b.n	2000031c <DMA_IRQHandler>

2000031e <UART0_IRQHandler>:
2000031e:	e7fe      	b.n	2000031e <UART0_IRQHandler>

20000320 <UART1_IRQHandler>:
20000320:	e7fe      	b.n	20000320 <UART1_IRQHandler>

20000322 <SPI0_IRQHandler>:
20000322:	e7fe      	b.n	20000322 <SPI0_IRQHandler>

20000324 <SPI1_IRQHandler>:
20000324:	e7fe      	b.n	20000324 <SPI1_IRQHandler>

20000326 <I2C0_IRQHandler>:
20000326:	e7fe      	b.n	20000326 <I2C0_IRQHandler>

20000328 <I2C0_SMBAlert_IRQHandler>:
20000328:	e7fe      	b.n	20000328 <I2C0_SMBAlert_IRQHandler>

2000032a <I2C0_SMBus_IRQHandler>:
2000032a:	e7fe      	b.n	2000032a <I2C0_SMBus_IRQHandler>

2000032c <I2C1_IRQHandler>:
2000032c:	e7fe      	b.n	2000032c <I2C1_IRQHandler>

2000032e <I2C1_SMBAlert_IRQHandler>:
2000032e:	e7fe      	b.n	2000032e <I2C1_SMBAlert_IRQHandler>

20000330 <I2C1_SMBus_IRQHandler>:
20000330:	e7fe      	b.n	20000330 <I2C1_SMBus_IRQHandler>

20000332 <Timer1_IRQHandler>:
20000332:	e7fe      	b.n	20000332 <Timer1_IRQHandler>

20000334 <Timer2_IRQHandler>:
20000334:	e7fe      	b.n	20000334 <Timer2_IRQHandler>

20000336 <PLL_Lock_IRQHandler>:
20000336:	e7fe      	b.n	20000336 <PLL_Lock_IRQHandler>

20000338 <PLL_LockLost_IRQHandler>:
20000338:	e7fe      	b.n	20000338 <PLL_LockLost_IRQHandler>

2000033a <CommError_IRQHandler>:
2000033a:	e7fe      	b.n	2000033a <CommError_IRQHandler>

2000033c <Fabric_IRQHandler>:
2000033c:	e7fe      	b.n	2000033c <Fabric_IRQHandler>
2000033e:	e7fe      	b.n	2000033e <Fabric_IRQHandler+0x2>

20000340 <GPIO1_IRQHandler>:
20000340:	e7fe      	b.n	20000340 <GPIO1_IRQHandler>

20000342 <GPIO2_IRQHandler>:
20000342:	e7fe      	b.n	20000342 <GPIO2_IRQHandler>

20000344 <GPIO3_IRQHandler>:
20000344:	e7fe      	b.n	20000344 <GPIO3_IRQHandler>

20000346 <GPIO4_IRQHandler>:
20000346:	e7fe      	b.n	20000346 <GPIO4_IRQHandler>

20000348 <GPIO5_IRQHandler>:
20000348:	e7fe      	b.n	20000348 <GPIO5_IRQHandler>

2000034a <GPIO6_IRQHandler>:
2000034a:	e7fe      	b.n	2000034a <GPIO6_IRQHandler>

2000034c <GPIO7_IRQHandler>:
2000034c:	e7fe      	b.n	2000034c <GPIO7_IRQHandler>

2000034e <GPIO8_IRQHandler>:
2000034e:	e7fe      	b.n	2000034e <GPIO8_IRQHandler>

20000350 <GPIO9_IRQHandler>:
20000350:	e7fe      	b.n	20000350 <GPIO9_IRQHandler>

20000352 <GPIO10_IRQHandler>:
20000352:	e7fe      	b.n	20000352 <GPIO10_IRQHandler>

20000354 <GPIO11_IRQHandler>:
20000354:	e7fe      	b.n	20000354 <GPIO11_IRQHandler>

20000356 <GPIO12_IRQHandler>:
20000356:	e7fe      	b.n	20000356 <GPIO12_IRQHandler>

20000358 <GPIO13_IRQHandler>:
20000358:	e7fe      	b.n	20000358 <GPIO13_IRQHandler>

2000035a <GPIO14_IRQHandler>:
2000035a:	e7fe      	b.n	2000035a <GPIO14_IRQHandler>

2000035c <GPIO15_IRQHandler>:
2000035c:	e7fe      	b.n	2000035c <GPIO15_IRQHandler>

2000035e <GPIO16_IRQHandler>:
2000035e:	e7fe      	b.n	2000035e <GPIO16_IRQHandler>

20000360 <GPIO17_IRQHandler>:
20000360:	e7fe      	b.n	20000360 <GPIO17_IRQHandler>

20000362 <GPIO18_IRQHandler>:
20000362:	e7fe      	b.n	20000362 <GPIO18_IRQHandler>

20000364 <GPIO19_IRQHandler>:
20000364:	e7fe      	b.n	20000364 <GPIO19_IRQHandler>

20000366 <GPIO20_IRQHandler>:
20000366:	e7fe      	b.n	20000366 <GPIO20_IRQHandler>

20000368 <GPIO21_IRQHandler>:
20000368:	e7fe      	b.n	20000368 <GPIO21_IRQHandler>

2000036a <GPIO22_IRQHandler>:
2000036a:	e7fe      	b.n	2000036a <GPIO22_IRQHandler>

2000036c <GPIO23_IRQHandler>:
2000036c:	e7fe      	b.n	2000036c <GPIO23_IRQHandler>

2000036e <GPIO24_IRQHandler>:
2000036e:	e7fe      	b.n	2000036e <GPIO24_IRQHandler>

20000370 <GPIO25_IRQHandler>:
20000370:	e7fe      	b.n	20000370 <GPIO25_IRQHandler>

20000372 <GPIO26_IRQHandler>:
20000372:	e7fe      	b.n	20000372 <GPIO26_IRQHandler>

20000374 <GPIO27_IRQHandler>:
20000374:	e7fe      	b.n	20000374 <GPIO27_IRQHandler>

20000376 <GPIO28_IRQHandler>:
20000376:	e7fe      	b.n	20000376 <GPIO28_IRQHandler>

20000378 <GPIO29_IRQHandler>:
20000378:	e7fe      	b.n	20000378 <GPIO29_IRQHandler>

2000037a <GPIO30_IRQHandler>:
2000037a:	e7fe      	b.n	2000037a <GPIO30_IRQHandler>

2000037c <GPIO31_IRQHandler>:
2000037c:	e7fe      	b.n	2000037c <GPIO31_IRQHandler>

2000037e <ACE_PC0_Flag0_IRQHandler>:
2000037e:	e7fe      	b.n	2000037e <ACE_PC0_Flag0_IRQHandler>

20000380 <ACE_PC0_Flag1_IRQHandler>:
20000380:	e7fe      	b.n	20000380 <ACE_PC0_Flag1_IRQHandler>

20000382 <ACE_PC0_Flag2_IRQHandler>:
20000382:	e7fe      	b.n	20000382 <ACE_PC0_Flag2_IRQHandler>

20000384 <ACE_PC0_Flag3_IRQHandler>:
20000384:	e7fe      	b.n	20000384 <ACE_PC0_Flag3_IRQHandler>

20000386 <ACE_PC1_Flag0_IRQHandler>:
20000386:	e7fe      	b.n	20000386 <ACE_PC1_Flag0_IRQHandler>

20000388 <ACE_PC1_Flag1_IRQHandler>:
20000388:	e7fe      	b.n	20000388 <ACE_PC1_Flag1_IRQHandler>

2000038a <ACE_PC1_Flag2_IRQHandler>:
2000038a:	e7fe      	b.n	2000038a <ACE_PC1_Flag2_IRQHandler>

2000038c <ACE_PC1_Flag3_IRQHandler>:
2000038c:	e7fe      	b.n	2000038c <ACE_PC1_Flag3_IRQHandler>

2000038e <ACE_PC2_Flag0_IRQHandler>:
2000038e:	e7fe      	b.n	2000038e <ACE_PC2_Flag0_IRQHandler>

20000390 <ACE_PC2_Flag1_IRQHandler>:
20000390:	e7fe      	b.n	20000390 <ACE_PC2_Flag1_IRQHandler>

20000392 <ACE_PC2_Flag2_IRQHandler>:
20000392:	e7fe      	b.n	20000392 <ACE_PC2_Flag2_IRQHandler>

20000394 <ACE_PC2_Flag3_IRQHandler>:
20000394:	e7fe      	b.n	20000394 <ACE_PC2_Flag3_IRQHandler>

20000396 <ACE_ADC0_DataValid_IRQHandler>:
20000396:	e7fe      	b.n	20000396 <ACE_ADC0_DataValid_IRQHandler>

20000398 <ACE_ADC1_DataValid_IRQHandler>:
20000398:	e7fe      	b.n	20000398 <ACE_ADC1_DataValid_IRQHandler>

2000039a <ACE_ADC2_DataValid_IRQHandler>:
2000039a:	e7fe      	b.n	2000039a <ACE_ADC2_DataValid_IRQHandler>

2000039c <ACE_ADC0_CalDone_IRQHandler>:
2000039c:	e7fe      	b.n	2000039c <ACE_ADC0_CalDone_IRQHandler>

2000039e <ACE_ADC1_CalDone_IRQHandler>:
2000039e:	e7fe      	b.n	2000039e <ACE_ADC1_CalDone_IRQHandler>

200003a0 <ACE_ADC2_CalDone_IRQHandler>:
200003a0:	e7fe      	b.n	200003a0 <ACE_ADC2_CalDone_IRQHandler>

200003a2 <ACE_ADC0_CalStart_IRQHandler>:
200003a2:	e7fe      	b.n	200003a2 <ACE_ADC0_CalStart_IRQHandler>

200003a4 <ACE_ADC1_CalStart_IRQHandler>:
200003a4:	e7fe      	b.n	200003a4 <ACE_ADC1_CalStart_IRQHandler>

200003a6 <ACE_ADC2_CalStart_IRQHandler>:
200003a6:	e7fe      	b.n	200003a6 <ACE_ADC2_CalStart_IRQHandler>

200003a8 <ACE_Comp0_Fall_IRQHandler>:
200003a8:	e7fe      	b.n	200003a8 <ACE_Comp0_Fall_IRQHandler>

200003aa <ACE_Comp1_Fall_IRQHandler>:
200003aa:	e7fe      	b.n	200003aa <ACE_Comp1_Fall_IRQHandler>

200003ac <ACE_Comp2_Fall_IRQHandler>:
200003ac:	e7fe      	b.n	200003ac <ACE_Comp2_Fall_IRQHandler>

200003ae <ACE_Comp3_Fall_IRQHandler>:
200003ae:	e7fe      	b.n	200003ae <ACE_Comp3_Fall_IRQHandler>

200003b0 <ACE_Comp4_Fall_IRQHandler>:
200003b0:	e7fe      	b.n	200003b0 <ACE_Comp4_Fall_IRQHandler>

200003b2 <ACE_Comp5_Fall_IRQHandler>:
200003b2:	e7fe      	b.n	200003b2 <ACE_Comp5_Fall_IRQHandler>

200003b4 <ACE_Comp6_Fall_IRQHandler>:
200003b4:	e7fe      	b.n	200003b4 <ACE_Comp6_Fall_IRQHandler>

200003b6 <ACE_Comp7_Fall_IRQHandler>:
200003b6:	e7fe      	b.n	200003b6 <ACE_Comp7_Fall_IRQHandler>

200003b8 <ACE_Comp8_Fall_IRQHandler>:
200003b8:	e7fe      	b.n	200003b8 <ACE_Comp8_Fall_IRQHandler>

200003ba <ACE_Comp9_Fall_IRQHandler>:
200003ba:	e7fe      	b.n	200003ba <ACE_Comp9_Fall_IRQHandler>

200003bc <ACE_Comp10_Fall_IRQHandler>:
200003bc:	e7fe      	b.n	200003bc <ACE_Comp10_Fall_IRQHandler>

200003be <ACE_Comp11_Fall_IRQHandler>:
200003be:	e7fe      	b.n	200003be <ACE_Comp11_Fall_IRQHandler>

200003c0 <ACE_Comp0_Rise_IRQHandler>:
200003c0:	e7fe      	b.n	200003c0 <ACE_Comp0_Rise_IRQHandler>

200003c2 <ACE_Comp1_Rise_IRQHandler>:
200003c2:	e7fe      	b.n	200003c2 <ACE_Comp1_Rise_IRQHandler>

200003c4 <ACE_Comp2_Rise_IRQHandler>:
200003c4:	e7fe      	b.n	200003c4 <ACE_Comp2_Rise_IRQHandler>

200003c6 <ACE_Comp3_Rise_IRQHandler>:
200003c6:	e7fe      	b.n	200003c6 <ACE_Comp3_Rise_IRQHandler>

200003c8 <ACE_Comp4_Rise_IRQHandler>:
200003c8:	e7fe      	b.n	200003c8 <ACE_Comp4_Rise_IRQHandler>

200003ca <ACE_Comp5_Rise_IRQHandler>:
200003ca:	e7fe      	b.n	200003ca <ACE_Comp5_Rise_IRQHandler>

200003cc <ACE_Comp6_Rise_IRQHandler>:
200003cc:	e7fe      	b.n	200003cc <ACE_Comp6_Rise_IRQHandler>

200003ce <ACE_Comp7_Rise_IRQHandler>:
200003ce:	e7fe      	b.n	200003ce <ACE_Comp7_Rise_IRQHandler>

200003d0 <ACE_Comp8_Rise_IRQHandler>:
200003d0:	e7fe      	b.n	200003d0 <ACE_Comp8_Rise_IRQHandler>

200003d2 <ACE_Comp9_Rise_IRQHandler>:
200003d2:	e7fe      	b.n	200003d2 <ACE_Comp9_Rise_IRQHandler>

200003d4 <ACE_Comp10_Rise_IRQHandler>:
200003d4:	e7fe      	b.n	200003d4 <ACE_Comp10_Rise_IRQHandler>

200003d6 <ACE_Comp11_Rise_IRQHandler>:
200003d6:	e7fe      	b.n	200003d6 <ACE_Comp11_Rise_IRQHandler>

200003d8 <ACE_ADC0_FifoFull_IRQHandler>:
200003d8:	e7fe      	b.n	200003d8 <ACE_ADC0_FifoFull_IRQHandler>

200003da <ACE_ADC0_FifoAFull_IRQHandler>:
200003da:	e7fe      	b.n	200003da <ACE_ADC0_FifoAFull_IRQHandler>

200003dc <ACE_ADC0_FifoEmpty_IRQHandler>:
200003dc:	e7fe      	b.n	200003dc <ACE_ADC0_FifoEmpty_IRQHandler>

200003de <ACE_ADC1_FifoFull_IRQHandler>:
200003de:	e7fe      	b.n	200003de <ACE_ADC1_FifoFull_IRQHandler>

200003e0 <ACE_ADC1_FifoAFull_IRQHandler>:
200003e0:	e7fe      	b.n	200003e0 <ACE_ADC1_FifoAFull_IRQHandler>

200003e2 <ACE_ADC1_FifoEmpty_IRQHandler>:
200003e2:	e7fe      	b.n	200003e2 <ACE_ADC1_FifoEmpty_IRQHandler>

200003e4 <ACE_ADC2_FifoFull_IRQHandler>:
200003e4:	e7fe      	b.n	200003e4 <ACE_ADC2_FifoFull_IRQHandler>

200003e6 <ACE_ADC2_FifoAFull_IRQHandler>:
200003e6:	e7fe      	b.n	200003e6 <ACE_ADC2_FifoAFull_IRQHandler>

200003e8 <ACE_ADC2_FifoEmpty_IRQHandler>:
200003e8:	e7fe      	b.n	200003e8 <ACE_ADC2_FifoEmpty_IRQHandler>

200003ea <ACE_PPE_Flag0_IRQHandler>:
200003ea:	e7fe      	b.n	200003ea <ACE_PPE_Flag0_IRQHandler>

200003ec <ACE_PPE_Flag1_IRQHandler>:
200003ec:	e7fe      	b.n	200003ec <ACE_PPE_Flag1_IRQHandler>

200003ee <ACE_PPE_Flag2_IRQHandler>:
200003ee:	e7fe      	b.n	200003ee <ACE_PPE_Flag2_IRQHandler>

200003f0 <ACE_PPE_Flag3_IRQHandler>:
200003f0:	e7fe      	b.n	200003f0 <ACE_PPE_Flag3_IRQHandler>

200003f2 <ACE_PPE_Flag4_IRQHandler>:
200003f2:	e7fe      	b.n	200003f2 <ACE_PPE_Flag4_IRQHandler>

200003f4 <ACE_PPE_Flag5_IRQHandler>:
200003f4:	e7fe      	b.n	200003f4 <ACE_PPE_Flag5_IRQHandler>

200003f6 <ACE_PPE_Flag6_IRQHandler>:
200003f6:	e7fe      	b.n	200003f6 <ACE_PPE_Flag6_IRQHandler>

200003f8 <ACE_PPE_Flag7_IRQHandler>:
200003f8:	e7fe      	b.n	200003f8 <ACE_PPE_Flag7_IRQHandler>

200003fa <ACE_PPE_Flag8_IRQHandler>:
200003fa:	e7fe      	b.n	200003fa <ACE_PPE_Flag8_IRQHandler>

200003fc <ACE_PPE_Flag9_IRQHandler>:
200003fc:	e7fe      	b.n	200003fc <ACE_PPE_Flag9_IRQHandler>

200003fe <ACE_PPE_Flag10_IRQHandler>:
200003fe:	e7fe      	b.n	200003fe <ACE_PPE_Flag10_IRQHandler>

20000400 <ACE_PPE_Flag11_IRQHandler>:
20000400:	e7fe      	b.n	20000400 <ACE_PPE_Flag11_IRQHandler>

20000402 <ACE_PPE_Flag12_IRQHandler>:
20000402:	e7fe      	b.n	20000402 <ACE_PPE_Flag12_IRQHandler>

20000404 <ACE_PPE_Flag13_IRQHandler>:
20000404:	e7fe      	b.n	20000404 <ACE_PPE_Flag13_IRQHandler>

20000406 <ACE_PPE_Flag14_IRQHandler>:
20000406:	e7fe      	b.n	20000406 <ACE_PPE_Flag14_IRQHandler>

20000408 <ACE_PPE_Flag15_IRQHandler>:
20000408:	e7fe      	b.n	20000408 <ACE_PPE_Flag15_IRQHandler>

2000040a <ACE_PPE_Flag16_IRQHandler>:
2000040a:	e7fe      	b.n	2000040a <ACE_PPE_Flag16_IRQHandler>

2000040c <ACE_PPE_Flag17_IRQHandler>:
2000040c:	e7fe      	b.n	2000040c <ACE_PPE_Flag17_IRQHandler>

2000040e <ACE_PPE_Flag18_IRQHandler>:
2000040e:	e7fe      	b.n	2000040e <ACE_PPE_Flag18_IRQHandler>

20000410 <ACE_PPE_Flag19_IRQHandler>:
20000410:	e7fe      	b.n	20000410 <ACE_PPE_Flag19_IRQHandler>

20000412 <ACE_PPE_Flag20_IRQHandler>:
20000412:	e7fe      	b.n	20000412 <ACE_PPE_Flag20_IRQHandler>

20000414 <ACE_PPE_Flag21_IRQHandler>:
20000414:	e7fe      	b.n	20000414 <ACE_PPE_Flag21_IRQHandler>

20000416 <ACE_PPE_Flag22_IRQHandler>:
20000416:	e7fe      	b.n	20000416 <ACE_PPE_Flag22_IRQHandler>

20000418 <ACE_PPE_Flag23_IRQHandler>:
20000418:	e7fe      	b.n	20000418 <ACE_PPE_Flag23_IRQHandler>

2000041a <ACE_PPE_Flag24_IRQHandler>:
2000041a:	e7fe      	b.n	2000041a <ACE_PPE_Flag24_IRQHandler>

2000041c <ACE_PPE_Flag25_IRQHandler>:
2000041c:	e7fe      	b.n	2000041c <ACE_PPE_Flag25_IRQHandler>

2000041e <ACE_PPE_Flag26_IRQHandler>:
2000041e:	e7fe      	b.n	2000041e <ACE_PPE_Flag26_IRQHandler>

20000420 <ACE_PPE_Flag27_IRQHandler>:
20000420:	e7fe      	b.n	20000420 <ACE_PPE_Flag27_IRQHandler>

20000422 <ACE_PPE_Flag28_IRQHandler>:
20000422:	e7fe      	b.n	20000422 <ACE_PPE_Flag28_IRQHandler>

20000424 <ACE_PPE_Flag29_IRQHandler>:
20000424:	e7fe      	b.n	20000424 <ACE_PPE_Flag29_IRQHandler>

20000426 <ACE_PPE_Flag30_IRQHandler>:
20000426:	e7fe      	b.n	20000426 <ACE_PPE_Flag30_IRQHandler>

20000428 <ACE_PPE_Flag31_IRQHandler>:
20000428:	e7fe      	b.n	20000428 <ACE_PPE_Flag31_IRQHandler>
2000042a:	0000      	.short	0x0000
2000042c:	2000087d 	.word	0x2000087d
20000430:	00000000 	.word	0x00000000
20000434:	20000000 	.word	0x20000000
20000438:	20000000 	.word	0x20000000
2000043c:	2000229c 	.word	0x2000229c
20000440:	2000229c 	.word	0x2000229c
20000444:	2000229c 	.word	0x2000229c
20000448:	200027c4 	.word	0x200027c4
2000044c:	00000000 	.word	0x00000000
20000450:	200027c4 	.word	0x200027c4
20000454:	20002830 	.word	0x20002830
20000458:	2000163d 	.word	0x2000163d
2000045c:	200005b5 	.word	0x200005b5

20000460 <__do_global_dtors_aux>:
20000460:	f242 73c4 	movw	r3, #10180	; 0x27c4
20000464:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000468:	781a      	ldrb	r2, [r3, #0]
2000046a:	b90a      	cbnz	r2, 20000470 <__do_global_dtors_aux+0x10>
2000046c:	2001      	movs	r0, #1
2000046e:	7018      	strb	r0, [r3, #0]
20000470:	4770      	bx	lr
20000472:	bf00      	nop

20000474 <frame_dummy>:
20000474:	f242 209c 	movw	r0, #8860	; 0x229c
20000478:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000047c:	b508      	push	{r3, lr}
2000047e:	6803      	ldr	r3, [r0, #0]
20000480:	b12b      	cbz	r3, 2000048e <frame_dummy+0x1a>
20000482:	f240 0300 	movw	r3, #0
20000486:	f2c0 0300 	movt	r3, #0
2000048a:	b103      	cbz	r3, 2000048e <frame_dummy+0x1a>
2000048c:	4798      	blx	r3
2000048e:	bd08      	pop	{r3, pc}

20000490 <NVIC_EnableIRQ>:
 *
 * Enable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
20000490:	b480      	push	{r7}
20000492:	b083      	sub	sp, #12
20000494:	af00      	add	r7, sp, #0
20000496:	4603      	mov	r3, r0
20000498:	80fb      	strh	r3, [r7, #6]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
2000049a:	f24e 1300 	movw	r3, #57600	; 0xe100
2000049e:	f2ce 0300 	movt	r3, #57344	; 0xe000
200004a2:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
200004a6:	ea4f 1252 	mov.w	r2, r2, lsr #5
200004aa:	88f9      	ldrh	r1, [r7, #6]
200004ac:	f001 011f 	and.w	r1, r1, #31
200004b0:	f04f 0001 	mov.w	r0, #1
200004b4:	fa00 f101 	lsl.w	r1, r0, r1
200004b8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
200004bc:	f107 070c 	add.w	r7, r7, #12
200004c0:	46bd      	mov	sp, r7
200004c2:	bc80      	pop	{r7}
200004c4:	4770      	bx	lr
200004c6:	bf00      	nop

200004c8 <NVIC_ClearPendingIRQ>:
 *
 * Clear the pending bit for the specified interrupt. 
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
200004c8:	b480      	push	{r7}
200004ca:	b083      	sub	sp, #12
200004cc:	af00      	add	r7, sp, #0
200004ce:	4603      	mov	r3, r0
200004d0:	80fb      	strh	r3, [r7, #6]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
200004d2:	f24e 1300 	movw	r3, #57600	; 0xe100
200004d6:	f2ce 0300 	movt	r3, #57344	; 0xe000
200004da:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
200004de:	ea4f 1252 	mov.w	r2, r2, lsr #5
200004e2:	88f9      	ldrh	r1, [r7, #6]
200004e4:	f001 011f 	and.w	r1, r1, #31
200004e8:	f04f 0001 	mov.w	r0, #1
200004ec:	fa00 f101 	lsl.w	r1, r0, r1
200004f0:	f102 0260 	add.w	r2, r2, #96	; 0x60
200004f4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
200004f8:	f107 070c 	add.w	r7, r7, #12
200004fc:	46bd      	mov	sp, r7
200004fe:	bc80      	pop	{r7}
20000500:	4770      	bx	lr
20000502:	bf00      	nop

20000504 <MSS_WD_disable>:
 
  @return
    This function does not return a value.
 */
static __INLINE void MSS_WD_disable( void )
{
20000504:	b480      	push	{r7}
20000506:	af00      	add	r7, sp, #0
    WATCHDOG->WDOGENABLE = MSS_WDOG_DISABLE_KEY;
20000508:	f246 0300 	movw	r3, #24576	; 0x6000
2000050c:	f2c4 0300 	movt	r3, #16384	; 0x4000
20000510:	f245 52fa 	movw	r2, #22010	; 0x55fa
20000514:	f6c4 426e 	movt	r2, #19566	; 0x4c6e
20000518:	611a      	str	r2, [r3, #16]
}
2000051a:	46bd      	mov	sp, r7
2000051c:	bc80      	pop	{r7}
2000051e:	4770      	bx	lr

20000520 <GPIO0_IRQHandler>:
uint8_t rx_data[MAX_RX_DATA_SIZE];
uint8_t parsed_rx_data[PARSED_RX_DATA_SIZE];
uint8_t rx_size;

__attribute__ ((interrupt)) void GPIO0_IRQHandler(void)
{
20000520:	4668      	mov	r0, sp
20000522:	f020 0107 	bic.w	r1, r0, #7
20000526:	468d      	mov	sp, r1
20000528:	b581      	push	{r0, r7, lr}
2000052a:	b083      	sub	sp, #12
2000052c:	af00      	add	r7, sp, #0
	/* RXRDY is high when data is available in the receive data buffer/FIFO.
	   This bit is cleared by reading the Receive Data Register.	 */
	rx_size = UART_get_rx(&g_barcode_uart, rx_data, MAX_RX_DATA_SIZE);
2000052e:	f642 0004 	movw	r0, #10244	; 0x2804
20000532:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000536:	f642 011c 	movw	r1, #10268	; 0x281c
2000053a:	f2c2 0100 	movt	r1, #8192	; 0x2000
2000053e:	f04f 020d 	mov.w	r2, #13
20000542:	f000 fea5 	bl	20001290 <UART_get_rx>
20000546:	4603      	mov	r3, r0
20000548:	b2da      	uxtb	r2, r3
2000054a:	f642 030c 	movw	r3, #10252	; 0x280c
2000054e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000552:	701a      	strb	r2, [r3, #0]

	int i;
	if(rx_size == 13) //if statement for debugging purposes
20000554:	f642 030c 	movw	r3, #10252	; 0x280c
20000558:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000055c:	781b      	ldrb	r3, [r3, #0]
2000055e:	2b0d      	cmp	r3, #13
20000560:	d119      	bne.n	20000596 <GPIO0_IRQHandler+0x76>
	{
		for(i=0; i < PARSED_RX_DATA_SIZE; i++){
20000562:	f04f 0300 	mov.w	r3, #0
20000566:	607b      	str	r3, [r7, #4]
20000568:	e012      	b.n	20000590 <GPIO0_IRQHandler+0x70>
			parsed_rx_data[i] = (rx_data[i] & 0x0F);
2000056a:	6879      	ldr	r1, [r7, #4]
2000056c:	687a      	ldr	r2, [r7, #4]
2000056e:	f642 031c 	movw	r3, #10268	; 0x281c
20000572:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000576:	5c9b      	ldrb	r3, [r3, r2]
20000578:	461a      	mov	r2, r3
2000057a:	f002 020f 	and.w	r2, r2, #15
2000057e:	f642 0310 	movw	r3, #10256	; 0x2810
20000582:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000586:	545a      	strb	r2, [r3, r1]
	rx_size = UART_get_rx(&g_barcode_uart, rx_data, MAX_RX_DATA_SIZE);

	int i;
	if(rx_size == 13) //if statement for debugging purposes
	{
		for(i=0; i < PARSED_RX_DATA_SIZE; i++){
20000588:	687b      	ldr	r3, [r7, #4]
2000058a:	f103 0301 	add.w	r3, r3, #1
2000058e:	607b      	str	r3, [r7, #4]
20000590:	687b      	ldr	r3, [r7, #4]
20000592:	2b0a      	cmp	r3, #10
20000594:	dde9      	ble.n	2000056a <GPIO0_IRQHandler+0x4a>
			parsed_rx_data[i] = (rx_data[i] & 0x0F);
		}
	}

	MSS_GPIO_clear_irq( MSS_GPIO_0 );
20000596:	f04f 0000 	mov.w	r0, #0
2000059a:	f000 fc13 	bl	20000dc4 <MSS_GPIO_clear_irq>
	NVIC_ClearPendingIRQ(GPIO0_IRQn);
2000059e:	f04f 0020 	mov.w	r0, #32
200005a2:	f7ff ff91 	bl	200004c8 <NVIC_ClearPendingIRQ>
}
200005a6:	f107 070c 	add.w	r7, r7, #12
200005aa:	46bd      	mov	sp, r7
200005ac:	e8bd 4081 	ldmia.w	sp!, {r0, r7, lr}
200005b0:	4685      	mov	sp, r0
200005b2:	4770      	bx	lr

200005b4 <main>:

int main()
{
200005b4:	b580      	push	{r7, lr}
200005b6:	af00      	add	r7, sp, #0
    /* Watchdog Disabling function */
    MSS_WD_disable();
200005b8:	f7ff ffa4 	bl	20000504 <MSS_WD_disable>

    /* Initialize the bar code scanner CoreUARTapb hardware */
    barcode_init();
200005bc:	f000 ffc8 	bl	20001550 <barcode_init>

    /* Initialize the MSS GPIO & GPIO_0 Interrupt */
    MSS_GPIO_init();
200005c0:	f000 fa9e 	bl	20000b00 <MSS_GPIO_init>
    MSS_GPIO_config( MSS_GPIO_0, MSS_GPIO_INPUT_MODE | MSS_GPIO_IRQ_EDGE_POSITIVE );
200005c4:	f04f 0000 	mov.w	r0, #0
200005c8:	f04f 0142 	mov.w	r1, #66	; 0x42
200005cc:	f000 face 	bl	20000b6c <MSS_GPIO_config>
    MSS_GPIO_enable_irq( MSS_GPIO_0 );
200005d0:	f04f 0000 	mov.w	r0, #0
200005d4:	f000 fb9c 	bl	20000d10 <MSS_GPIO_enable_irq>
    NVIC_EnableIRQ(GPIO0_IRQn);
200005d8:	f04f 0020 	mov.w	r0, #32
200005dc:	f7ff ff58 	bl	20000490 <NVIC_EnableIRQ>

    while(1){}
200005e0:	e7fe      	b.n	200005e0 <main+0x2c>
200005e2:	bf00      	nop

200005e4 <_close>:

/*==============================================================================
 * Close a file.
 */
int _close(int file)
{
200005e4:	b480      	push	{r7}
200005e6:	b083      	sub	sp, #12
200005e8:	af00      	add	r7, sp, #0
200005ea:	6078      	str	r0, [r7, #4]
    return -1;
200005ec:	f04f 33ff 	mov.w	r3, #4294967295
}
200005f0:	4618      	mov	r0, r3
200005f2:	f107 070c 	add.w	r7, r7, #12
200005f6:	46bd      	mov	sp, r7
200005f8:	bc80      	pop	{r7}
200005fa:	4770      	bx	lr

200005fc <_execve>:

/*==============================================================================
 * Transfer control to a new process.
 */
int _execve(char *name, char **argv, char **env)
{
200005fc:	b480      	push	{r7}
200005fe:	b085      	sub	sp, #20
20000600:	af00      	add	r7, sp, #0
20000602:	60f8      	str	r0, [r7, #12]
20000604:	60b9      	str	r1, [r7, #8]
20000606:	607a      	str	r2, [r7, #4]
    errno = ENOMEM;
20000608:	f642 032c 	movw	r3, #10284	; 0x282c
2000060c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000610:	f04f 020c 	mov.w	r2, #12
20000614:	601a      	str	r2, [r3, #0]
    return -1;
20000616:	f04f 33ff 	mov.w	r3, #4294967295
}
2000061a:	4618      	mov	r0, r3
2000061c:	f107 0714 	add.w	r7, r7, #20
20000620:	46bd      	mov	sp, r7
20000622:	bc80      	pop	{r7}
20000624:	4770      	bx	lr
20000626:	bf00      	nop

20000628 <_exit>:
{
	/* Should we force a system reset? */
	while( 1 )
	{
		;
	}
20000628:	b480      	push	{r7}
2000062a:	b083      	sub	sp, #12
2000062c:	af00      	add	r7, sp, #0
2000062e:	6078      	str	r0, [r7, #4]
20000630:	e7fe      	b.n	20000630 <_exit+0x8>
20000632:	bf00      	nop

20000634 <_fork>:

/*==============================================================================
 * Create a new process.
 */
int _fork(void)
{
20000634:	b480      	push	{r7}
20000636:	af00      	add	r7, sp, #0
    errno = EAGAIN;
20000638:	f642 032c 	movw	r3, #10284	; 0x282c
2000063c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000640:	f04f 020b 	mov.w	r2, #11
20000644:	601a      	str	r2, [r3, #0]
    return -1;
20000646:	f04f 33ff 	mov.w	r3, #4294967295
}
2000064a:	4618      	mov	r0, r3
2000064c:	46bd      	mov	sp, r7
2000064e:	bc80      	pop	{r7}
20000650:	4770      	bx	lr
20000652:	bf00      	nop

20000654 <_fstat>:

/*==============================================================================
 * Status of an open file.
 */
int _fstat(int file, struct stat *st)
{
20000654:	b480      	push	{r7}
20000656:	b083      	sub	sp, #12
20000658:	af00      	add	r7, sp, #0
2000065a:	6078      	str	r0, [r7, #4]
2000065c:	6039      	str	r1, [r7, #0]
    st->st_mode = S_IFCHR;
2000065e:	683b      	ldr	r3, [r7, #0]
20000660:	f44f 5200 	mov.w	r2, #8192	; 0x2000
20000664:	605a      	str	r2, [r3, #4]
    return 0;
20000666:	f04f 0300 	mov.w	r3, #0
}
2000066a:	4618      	mov	r0, r3
2000066c:	f107 070c 	add.w	r7, r7, #12
20000670:	46bd      	mov	sp, r7
20000672:	bc80      	pop	{r7}
20000674:	4770      	bx	lr
20000676:	bf00      	nop

20000678 <_getpid>:

/*==============================================================================
 * Process-ID
 */
int _getpid(void)
{
20000678:	b480      	push	{r7}
2000067a:	af00      	add	r7, sp, #0
    return 1;
2000067c:	f04f 0301 	mov.w	r3, #1
}
20000680:	4618      	mov	r0, r3
20000682:	46bd      	mov	sp, r7
20000684:	bc80      	pop	{r7}
20000686:	4770      	bx	lr

20000688 <_isatty>:

/*==============================================================================
 * Query whether output stream is a terminal.
 */
int _isatty(int file)
{
20000688:	b480      	push	{r7}
2000068a:	b083      	sub	sp, #12
2000068c:	af00      	add	r7, sp, #0
2000068e:	6078      	str	r0, [r7, #4]
    return 1;
20000690:	f04f 0301 	mov.w	r3, #1
}
20000694:	4618      	mov	r0, r3
20000696:	f107 070c 	add.w	r7, r7, #12
2000069a:	46bd      	mov	sp, r7
2000069c:	bc80      	pop	{r7}
2000069e:	4770      	bx	lr

200006a0 <_kill>:

/*==============================================================================
 * Send a signal.
 */
int _kill(int pid, int sig)
{
200006a0:	b480      	push	{r7}
200006a2:	b083      	sub	sp, #12
200006a4:	af00      	add	r7, sp, #0
200006a6:	6078      	str	r0, [r7, #4]
200006a8:	6039      	str	r1, [r7, #0]
    errno = EINVAL;
200006aa:	f642 032c 	movw	r3, #10284	; 0x282c
200006ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
200006b2:	f04f 0216 	mov.w	r2, #22
200006b6:	601a      	str	r2, [r3, #0]
    return -1;
200006b8:	f04f 33ff 	mov.w	r3, #4294967295
}
200006bc:	4618      	mov	r0, r3
200006be:	f107 070c 	add.w	r7, r7, #12
200006c2:	46bd      	mov	sp, r7
200006c4:	bc80      	pop	{r7}
200006c6:	4770      	bx	lr

200006c8 <_link>:

/*==============================================================================
 * Establish a new name for an existing file.
 */
int _link(char *old, char *new)
{
200006c8:	b480      	push	{r7}
200006ca:	b083      	sub	sp, #12
200006cc:	af00      	add	r7, sp, #0
200006ce:	6078      	str	r0, [r7, #4]
200006d0:	6039      	str	r1, [r7, #0]
    errno = EMLINK;
200006d2:	f642 032c 	movw	r3, #10284	; 0x282c
200006d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200006da:	f04f 021f 	mov.w	r2, #31
200006de:	601a      	str	r2, [r3, #0]
    return -1;
200006e0:	f04f 33ff 	mov.w	r3, #4294967295
}
200006e4:	4618      	mov	r0, r3
200006e6:	f107 070c 	add.w	r7, r7, #12
200006ea:	46bd      	mov	sp, r7
200006ec:	bc80      	pop	{r7}
200006ee:	4770      	bx	lr

200006f0 <_lseek>:

/*==============================================================================
 * Set position in a file.
 */
int _lseek(int file, int ptr, int dir)
{
200006f0:	b480      	push	{r7}
200006f2:	b085      	sub	sp, #20
200006f4:	af00      	add	r7, sp, #0
200006f6:	60f8      	str	r0, [r7, #12]
200006f8:	60b9      	str	r1, [r7, #8]
200006fa:	607a      	str	r2, [r7, #4]
    return 0;
200006fc:	f04f 0300 	mov.w	r3, #0
}
20000700:	4618      	mov	r0, r3
20000702:	f107 0714 	add.w	r7, r7, #20
20000706:	46bd      	mov	sp, r7
20000708:	bc80      	pop	{r7}
2000070a:	4770      	bx	lr

2000070c <_open>:

/*==============================================================================
 * Open a file.
 */
int _open(const char *name, int flags, int mode)
{
2000070c:	b480      	push	{r7}
2000070e:	b085      	sub	sp, #20
20000710:	af00      	add	r7, sp, #0
20000712:	60f8      	str	r0, [r7, #12]
20000714:	60b9      	str	r1, [r7, #8]
20000716:	607a      	str	r2, [r7, #4]
    return -1;
20000718:	f04f 33ff 	mov.w	r3, #4294967295
}
2000071c:	4618      	mov	r0, r3
2000071e:	f107 0714 	add.w	r7, r7, #20
20000722:	46bd      	mov	sp, r7
20000724:	bc80      	pop	{r7}
20000726:	4770      	bx	lr

20000728 <_read>:

/*==============================================================================
 * Read from a file.
 */
int _read(int file, char *ptr, int len)
{
20000728:	b480      	push	{r7}
2000072a:	b085      	sub	sp, #20
2000072c:	af00      	add	r7, sp, #0
2000072e:	60f8      	str	r0, [r7, #12]
20000730:	60b9      	str	r1, [r7, #8]
20000732:	607a      	str	r2, [r7, #4]
    return 0;
20000734:	f04f 0300 	mov.w	r3, #0
}
20000738:	4618      	mov	r0, r3
2000073a:	f107 0714 	add.w	r7, r7, #20
2000073e:	46bd      	mov	sp, r7
20000740:	bc80      	pop	{r7}
20000742:	4770      	bx	lr

20000744 <_sbrk>:
 * it is useful to have a working implementation. The following suffices for a
 * standalone system; it exploits the symbol _end automatically defined by the
 * GNU linker. 
 */
caddr_t _sbrk(int incr)
{
20000744:	b580      	push	{r7, lr}
20000746:	b084      	sub	sp, #16
20000748:	af00      	add	r7, sp, #0
2000074a:	6078      	str	r0, [r7, #4]
    extern char _end;		/* Defined by the linker */
    static char *heap_end;
    char *prev_heap_end;
    char * stack_ptr;
    
    if (heap_end == 0)
2000074c:	f242 73cc 	movw	r3, #10188	; 0x27cc
20000750:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000754:	681b      	ldr	r3, [r3, #0]
20000756:	2b00      	cmp	r3, #0
20000758:	d108      	bne.n	2000076c <_sbrk+0x28>
    {
      heap_end = &_end;
2000075a:	f242 73cc 	movw	r3, #10188	; 0x27cc
2000075e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000762:	f642 0230 	movw	r2, #10288	; 0x2830
20000766:	f2c2 0200 	movt	r2, #8192	; 0x2000
2000076a:	601a      	str	r2, [r3, #0]
    }
    
    prev_heap_end = heap_end;
2000076c:	f242 73cc 	movw	r3, #10188	; 0x27cc
20000770:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000774:	681b      	ldr	r3, [r3, #0]
20000776:	60bb      	str	r3, [r7, #8]
    asm volatile ("MRS %0, msp" : "=r" (stack_ptr) );
20000778:	f3ef 8308 	mrs	r3, MSP
2000077c:	60fb      	str	r3, [r7, #12]
    if (heap_end + incr > stack_ptr)
2000077e:	f242 73cc 	movw	r3, #10188	; 0x27cc
20000782:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000786:	681a      	ldr	r2, [r3, #0]
20000788:	687b      	ldr	r3, [r7, #4]
2000078a:	441a      	add	r2, r3
2000078c:	68fb      	ldr	r3, [r7, #12]
2000078e:	429a      	cmp	r2, r3
20000790:	d90b      	bls.n	200007aa <_sbrk+0x66>
    {
      write (1, "Heap and stack collision\n", 25);
20000792:	f04f 0001 	mov.w	r0, #1
20000796:	f242 116c 	movw	r1, #8556	; 0x216c
2000079a:	f2c2 0100 	movt	r1, #8192	; 0x2000
2000079e:	f04f 0219 	mov.w	r2, #25
200007a2:	f001 f8b7 	bl	20001914 <write>
      abort ();
200007a6:	f000 ff41 	bl	2000162c <abort>
    }
  
    heap_end += incr;
200007aa:	f242 73cc 	movw	r3, #10188	; 0x27cc
200007ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
200007b2:	681a      	ldr	r2, [r3, #0]
200007b4:	687b      	ldr	r3, [r7, #4]
200007b6:	441a      	add	r2, r3
200007b8:	f242 73cc 	movw	r3, #10188	; 0x27cc
200007bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
200007c0:	601a      	str	r2, [r3, #0]
    return (caddr_t) prev_heap_end;
200007c2:	68bb      	ldr	r3, [r7, #8]
}
200007c4:	4618      	mov	r0, r3
200007c6:	f107 0710 	add.w	r7, r7, #16
200007ca:	46bd      	mov	sp, r7
200007cc:	bd80      	pop	{r7, pc}
200007ce:	bf00      	nop

200007d0 <_stat>:

/*==============================================================================
 * Status of a file (by name).
 */
int _stat(char *file, struct stat *st)
{
200007d0:	b480      	push	{r7}
200007d2:	b083      	sub	sp, #12
200007d4:	af00      	add	r7, sp, #0
200007d6:	6078      	str	r0, [r7, #4]
200007d8:	6039      	str	r1, [r7, #0]
    st->st_mode = S_IFCHR;
200007da:	683b      	ldr	r3, [r7, #0]
200007dc:	f44f 5200 	mov.w	r2, #8192	; 0x2000
200007e0:	605a      	str	r2, [r3, #4]
    return 0;
200007e2:	f04f 0300 	mov.w	r3, #0
}
200007e6:	4618      	mov	r0, r3
200007e8:	f107 070c 	add.w	r7, r7, #12
200007ec:	46bd      	mov	sp, r7
200007ee:	bc80      	pop	{r7}
200007f0:	4770      	bx	lr
200007f2:	bf00      	nop

200007f4 <_times>:

/*==============================================================================
 * Timing information for current process.
 */
int _times(struct tms *buf)
{
200007f4:	b480      	push	{r7}
200007f6:	b083      	sub	sp, #12
200007f8:	af00      	add	r7, sp, #0
200007fa:	6078      	str	r0, [r7, #4]
    return -1;
200007fc:	f04f 33ff 	mov.w	r3, #4294967295
}
20000800:	4618      	mov	r0, r3
20000802:	f107 070c 	add.w	r7, r7, #12
20000806:	46bd      	mov	sp, r7
20000808:	bc80      	pop	{r7}
2000080a:	4770      	bx	lr

2000080c <_unlink>:

/*==============================================================================
 * Remove a file's directory entry.
 */
int _unlink(char *name)
{
2000080c:	b480      	push	{r7}
2000080e:	b083      	sub	sp, #12
20000810:	af00      	add	r7, sp, #0
20000812:	6078      	str	r0, [r7, #4]
    errno = ENOENT;
20000814:	f642 032c 	movw	r3, #10284	; 0x282c
20000818:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000081c:	f04f 0202 	mov.w	r2, #2
20000820:	601a      	str	r2, [r3, #0]
    return -1;
20000822:	f04f 33ff 	mov.w	r3, #4294967295
}
20000826:	4618      	mov	r0, r3
20000828:	f107 070c 	add.w	r7, r7, #12
2000082c:	46bd      	mov	sp, r7
2000082e:	bc80      	pop	{r7}
20000830:	4770      	bx	lr
20000832:	bf00      	nop

20000834 <_wait>:

/*==============================================================================
 * Wait for a child process.
 */
int _wait(int *status)
{
20000834:	b480      	push	{r7}
20000836:	b083      	sub	sp, #12
20000838:	af00      	add	r7, sp, #0
2000083a:	6078      	str	r0, [r7, #4]
    errno = ECHILD;
2000083c:	f642 032c 	movw	r3, #10284	; 0x282c
20000840:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000844:	f04f 020a 	mov.w	r2, #10
20000848:	601a      	str	r2, [r3, #0]
    return -1;
2000084a:	f04f 33ff 	mov.w	r3, #4294967295
}
2000084e:	4618      	mov	r0, r3
20000850:	f107 070c 	add.w	r7, r7, #12
20000854:	46bd      	mov	sp, r7
20000856:	bc80      	pop	{r7}
20000858:	4770      	bx	lr
2000085a:	bf00      	nop

2000085c <_write_r>:
 * all files, including stdout—so if you need to generate any output, for
 * example to a serial port for debugging, you should make your minimal write
 * capable of doing this.
 */
int _write_r( void * reent, int file, char * ptr, int len )
{
2000085c:	b480      	push	{r7}
2000085e:	b085      	sub	sp, #20
20000860:	af00      	add	r7, sp, #0
20000862:	60f8      	str	r0, [r7, #12]
20000864:	60b9      	str	r1, [r7, #8]
20000866:	607a      	str	r2, [r7, #4]
20000868:	603b      	str	r3, [r7, #0]
	 */
	MSS_UART_polled_tx( &g_mss_uart0, (uint8_t *)ptr, len );
	
	return len;
#else	/* ACTEL_STDIO_THRU_UART */
	return 0;
2000086a:	f04f 0300 	mov.w	r3, #0
#endif	/* ACTEL_STDIO_THRU_UART */
}
2000086e:	4618      	mov	r0, r3
20000870:	f107 0714 	add.w	r7, r7, #20
20000874:	46bd      	mov	sp, r7
20000876:	bc80      	pop	{r7}
20000878:	4770      	bx	lr
2000087a:	bf00      	nop

2000087c <SystemInit>:

/***************************************************************************//**
 * See system_a2fm3fxxx.h for details.
 */
void SystemInit(void)
{
2000087c:	b480      	push	{r7}
2000087e:	af00      	add	r7, sp, #0
}
20000880:	46bd      	mov	sp, r7
20000882:	bc80      	pop	{r7}
20000884:	4770      	bx	lr
20000886:	bf00      	nop

20000888 <SystemCoreClockUpdate>:

/***************************************************************************//**
 *
 */
void SystemCoreClockUpdate (void)
{
20000888:	b580      	push	{r7, lr}
2000088a:	b08a      	sub	sp, #40	; 0x28
2000088c:	af00      	add	r7, sp, #0
    uint32_t PclkDiv0;
    uint32_t PclkDiv1;
    uint32_t AceDiv;
    uint32_t FabDiv;

    const uint32_t pclk_div_lut[4] = { 1uL, 2uL, 4uL, 1uL };
2000088e:	f242 1388 	movw	r3, #8584	; 0x2188
20000892:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000896:	46bc      	mov	ip, r7
20000898:	cb0f      	ldmia	r3!, {r0, r1, r2, r3}
2000089a:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}

    /* Read PCLK dividers from system registers. Multiply the value read from
     * system register by two to get actual divider value. */
    PclkDiv0 = pclk_div_lut[((SYSREG->MSS_CLK_CR >> PCLK0_DIV_SHIFT) & PCLK_DIV_MASK)];
2000089e:	f242 0300 	movw	r3, #8192	; 0x2000
200008a2:	f2ce 0304 	movt	r3, #57348	; 0xe004
200008a6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
200008a8:	ea4f 0393 	mov.w	r3, r3, lsr #2
200008ac:	f003 0303 	and.w	r3, r3, #3
200008b0:	ea4f 0383 	mov.w	r3, r3, lsl #2
200008b4:	f107 0228 	add.w	r2, r7, #40	; 0x28
200008b8:	4413      	add	r3, r2
200008ba:	f853 3c28 	ldr.w	r3, [r3, #-40]
200008be:	613b      	str	r3, [r7, #16]
    PclkDiv1 = pclk_div_lut[((SYSREG->MSS_CLK_CR >> PCLK1_DIV_SHIFT) & PCLK_DIV_MASK)];
200008c0:	f242 0300 	movw	r3, #8192	; 0x2000
200008c4:	f2ce 0304 	movt	r3, #57348	; 0xe004
200008c8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
200008ca:	ea4f 1313 	mov.w	r3, r3, lsr #4
200008ce:	f003 0303 	and.w	r3, r3, #3
200008d2:	ea4f 0383 	mov.w	r3, r3, lsl #2
200008d6:	f107 0228 	add.w	r2, r7, #40	; 0x28
200008da:	4413      	add	r3, r2
200008dc:	f853 3c28 	ldr.w	r3, [r3, #-40]
200008e0:	617b      	str	r3, [r7, #20]
    AceDiv = pclk_div_lut[((SYSREG->MSS_CLK_CR >> ACE_DIV_SHIFT) & PCLK_DIV_MASK)];
200008e2:	f242 0300 	movw	r3, #8192	; 0x2000
200008e6:	f2ce 0304 	movt	r3, #57348	; 0xe004
200008ea:	6c9b      	ldr	r3, [r3, #72]	; 0x48
200008ec:	ea4f 1393 	mov.w	r3, r3, lsr #6
200008f0:	f003 0303 	and.w	r3, r3, #3
200008f4:	ea4f 0383 	mov.w	r3, r3, lsl #2
200008f8:	f107 0228 	add.w	r2, r7, #40	; 0x28
200008fc:	4413      	add	r3, r2
200008fe:	f853 3c28 	ldr.w	r3, [r3, #-40]
20000902:	61bb      	str	r3, [r7, #24]
    {
        /* Compute the FPGA fabric frequency divider. */
        uint32_t obdiv;
        uint32_t obdivhalf;
        
        obdiv = (SYSREG->MSS_CCC_DIV_CR >> OBDIV_SHIFT) & OBDIV_MASK;
20000904:	f242 0300 	movw	r3, #8192	; 0x2000
20000908:	f2ce 0304 	movt	r3, #57348	; 0xe004
2000090c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2000090e:	ea4f 2313 	mov.w	r3, r3, lsr #8
20000912:	f003 031f 	and.w	r3, r3, #31
20000916:	623b      	str	r3, [r7, #32]
        obdivhalf = (SYSREG->MSS_CCC_DIV_CR >> OBDIVHALF_SHIFT) & OBDIVHALF_MASK;
20000918:	f242 0300 	movw	r3, #8192	; 0x2000
2000091c:	f2ce 0304 	movt	r3, #57348	; 0xe004
20000920:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
20000922:	ea4f 3353 	mov.w	r3, r3, lsr #13
20000926:	f003 0301 	and.w	r3, r3, #1
2000092a:	627b      	str	r3, [r7, #36]	; 0x24
        FabDiv = obdiv + 1uL;
2000092c:	6a3b      	ldr	r3, [r7, #32]
2000092e:	f103 0301 	add.w	r3, r3, #1
20000932:	61fb      	str	r3, [r7, #28]
        if ( obdivhalf != 0uL )
20000934:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20000936:	2b00      	cmp	r3, #0
20000938:	d003      	beq.n	20000942 <SystemCoreClockUpdate+0xba>
        {
            FabDiv = FabDiv * 2uL;
2000093a:	69fb      	ldr	r3, [r7, #28]
2000093c:	ea4f 0343 	mov.w	r3, r3, lsl #1
20000940:	61fb      	str	r3, [r7, #28]
    }
    
    /* Retrieve FCLK from eNVM spare pages if Actel system boot programmed as part of the system. */
    
    /* Read system clock from eNVM spare pages. */
    SystemCoreClock = GetSystemClock();
20000942:	f000 f849 	bl	200009d8 <GetSystemClock>
20000946:	4602      	mov	r2, r0
20000948:	f242 23ac 	movw	r3, #8876	; 0x22ac
2000094c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000950:	601a      	str	r2, [r3, #0]
    g_FrequencyPCLK0 = SystemCoreClock / PclkDiv0;
20000952:	f242 23ac 	movw	r3, #8876	; 0x22ac
20000956:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000095a:	681a      	ldr	r2, [r3, #0]
2000095c:	693b      	ldr	r3, [r7, #16]
2000095e:	fbb2 f2f3 	udiv	r2, r2, r3
20000962:	f242 23b0 	movw	r3, #8880	; 0x22b0
20000966:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000096a:	601a      	str	r2, [r3, #0]
    g_FrequencyPCLK1 = SystemCoreClock / PclkDiv1;
2000096c:	f242 23ac 	movw	r3, #8876	; 0x22ac
20000970:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000974:	681a      	ldr	r2, [r3, #0]
20000976:	697b      	ldr	r3, [r7, #20]
20000978:	fbb2 f2f3 	udiv	r2, r2, r3
2000097c:	f242 23b4 	movw	r3, #8884	; 0x22b4
20000980:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000984:	601a      	str	r2, [r3, #0]
    g_FrequencyACE = SystemCoreClock / AceDiv;
20000986:	f242 23ac 	movw	r3, #8876	; 0x22ac
2000098a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000098e:	681a      	ldr	r2, [r3, #0]
20000990:	69bb      	ldr	r3, [r7, #24]
20000992:	fbb2 f2f3 	udiv	r2, r2, r3
20000996:	f242 23b8 	movw	r3, #8888	; 0x22b8
2000099a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000099e:	601a      	str	r2, [r3, #0]
    g_FrequencyFPGA = SystemCoreClock / FabDiv;
200009a0:	f242 23ac 	movw	r3, #8876	; 0x22ac
200009a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200009a8:	681a      	ldr	r2, [r3, #0]
200009aa:	69fb      	ldr	r3, [r7, #28]
200009ac:	fbb2 f2f3 	udiv	r2, r2, r3
200009b0:	f242 23bc 	movw	r3, #8892	; 0x22bc
200009b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200009b8:	601a      	str	r2, [r3, #0]
    
    /* Keep SystemFrequency as well as SystemCoreClock for legacy reasons. */
    SystemFrequency = SystemCoreClock;
200009ba:	f242 23ac 	movw	r3, #8876	; 0x22ac
200009be:	f2c2 0300 	movt	r3, #8192	; 0x2000
200009c2:	681a      	ldr	r2, [r3, #0]
200009c4:	f242 23a8 	movw	r3, #8872	; 0x22a8
200009c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200009cc:	601a      	str	r2, [r3, #0]
}
200009ce:	f107 0728 	add.w	r7, r7, #40	; 0x28
200009d2:	46bd      	mov	sp, r7
200009d4:	bd80      	pop	{r7, pc}
200009d6:	bf00      	nop

200009d8 <GetSystemClock>:
 * retrieved from eNVM spare pages.
 * The FCLK frequency value selected in the MSS Configurator software tool is
 * stored in eNVM spare pages as part of the Actel system boot configuration data.
 */
uint32_t GetSystemClock( void )
{
200009d8:	b480      	push	{r7}
200009da:	b087      	sub	sp, #28
200009dc:	af00      	add	r7, sp, #0
    uint32_t fclk = 0uL;
200009de:	f04f 0300 	mov.w	r3, #0
200009e2:	603b      	str	r3, [r7, #0]
    
    uint32_t * p_sysboot_key = SYSBOOT_KEY_ADDR;
200009e4:	f640 031c 	movw	r3, #2076	; 0x81c
200009e8:	f2c6 0308 	movt	r3, #24584	; 0x6008
200009ec:	607b      	str	r3, [r7, #4]
    
    if ( SYSBOOT_KEY_VALUE == *p_sysboot_key )
200009ee:	687b      	ldr	r3, [r7, #4]
200009f0:	681a      	ldr	r2, [r3, #0]
200009f2:	f244 3341 	movw	r3, #17217	; 0x4341
200009f6:	f6c4 4354 	movt	r3, #19540	; 0x4c54
200009fa:	429a      	cmp	r2, r3
200009fc:	d135      	bne.n	20000a6a <GetSystemClock+0x92>
    {
        /* Actel system boot programmed, check if it has the FCLK value stored. */
        uint32_t *p_sysboot_version = SYSBOOT_VERSION_ADDR;
200009fe:	f640 0340 	movw	r3, #2112	; 0x840
20000a02:	f2c6 0308 	movt	r3, #24584	; 0x6008
20000a06:	60bb      	str	r3, [r7, #8]
        uint32_t sysboot_version = *p_sysboot_version;
20000a08:	68bb      	ldr	r3, [r7, #8]
20000a0a:	681b      	ldr	r3, [r3, #0]
20000a0c:	60fb      	str	r3, [r7, #12]
        
        sysboot_version &= SYSBOOT_VERSION_MASK;
20000a0e:	68fb      	ldr	r3, [r7, #12]
20000a10:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
20000a14:	60fb      	str	r3, [r7, #12]
        
        if ( sysboot_version >= MIN_SYSBOOT_VERSION )
20000a16:	68fa      	ldr	r2, [r7, #12]
20000a18:	f240 3300 	movw	r3, #768	; 0x300
20000a1c:	f2c0 0301 	movt	r3, #1
20000a20:	429a      	cmp	r2, r3
20000a22:	d922      	bls.n	20000a6a <GetSystemClock+0x92>
        {
            /* Handle change of eNVM location of FCLK between 1.3.x and 2.x.x versions of the system boot. */
            if ( sysboot_version < SYSBOOT_VERSION_2_X )
20000a24:	68fa      	ldr	r2, [r7, #12]
20000a26:	f64f 73ff 	movw	r3, #65535	; 0xffff
20000a2a:	f2c0 0301 	movt	r3, #1
20000a2e:	429a      	cmp	r2, r3
20000a30:	d808      	bhi.n	20000a44 <GetSystemClock+0x6c>
            {
                /* Read FCLK value from MSS configurator generated configuration
                 * data stored in eNVM spare pages as part of system boot version 1.3.x
                 * configuration tables. */
                uint32_t *p_fclk = SYSBOOT_1_3_FCLK_ADDR;
20000a32:	f241 632c 	movw	r3, #5676	; 0x162c
20000a36:	f2c6 0308 	movt	r3, #24584	; 0x6008
20000a3a:	613b      	str	r3, [r7, #16]
                fclk = *p_fclk;
20000a3c:	693b      	ldr	r3, [r7, #16]
20000a3e:	681b      	ldr	r3, [r3, #0]
20000a40:	603b      	str	r3, [r7, #0]
20000a42:	e012      	b.n	20000a6a <GetSystemClock+0x92>
            }
            else if ( sysboot_version < MAX_SYSBOOT_VERSION )
20000a44:	68fa      	ldr	r2, [r7, #12]
20000a46:	f64f 73ff 	movw	r3, #65535	; 0xffff
20000a4a:	f2c0 0302 	movt	r3, #2
20000a4e:	429a      	cmp	r2, r3
20000a50:	d808      	bhi.n	20000a64 <GetSystemClock+0x8c>
            {
                /* Read FCLK value from MSS configurator generated configuration
                 * data stored in eNVM spare pages as part of system boot version 2.x.x
                 * configuration tables. */
                uint32_t *p_fclk = SYSBOOT_2_x_FCLK_ADDR;
20000a52:	f641 63ac 	movw	r3, #7852	; 0x1eac
20000a56:	f2c6 0308 	movt	r3, #24584	; 0x6008
20000a5a:	617b      	str	r3, [r7, #20]
                fclk = *p_fclk;
20000a5c:	697b      	ldr	r3, [r7, #20]
20000a5e:	681b      	ldr	r3, [r3, #0]
20000a60:	603b      	str	r3, [r7, #0]
20000a62:	e002      	b.n	20000a6a <GetSystemClock+0x92>
            }
            else
            {
                fclk = 0uL;
20000a64:	f04f 0300 	mov.w	r3, #0
20000a68:	603b      	str	r3, [r7, #0]
            }
        }
    }
    
    if ( 0uL == fclk )
20000a6a:	683b      	ldr	r3, [r7, #0]
20000a6c:	2b00      	cmp	r3, #0
20000a6e:	d105      	bne.n	20000a7c <GetSystemClock+0xa4>
        /* 
         * Could not retrieve FCLK from system boot configuration data. Fall back
         * to using SMARTFUSION_FCLK_FREQ which must then be defined as part of
         * project settings.
         */
        ASSERT( SMARTFUSION_FCLK_FREQ_DEFINED );
20000a70:	be00      	bkpt	0x0000
        fclk = SMARTFUSION_FCLK_FREQ;
20000a72:	f647 0340 	movw	r3, #30784	; 0x7840
20000a76:	f2c0 137d 	movt	r3, #381	; 0x17d
20000a7a:	603b      	str	r3, [r7, #0]
    }
    
    return fclk;
20000a7c:	683b      	ldr	r3, [r7, #0]
}
20000a7e:	4618      	mov	r0, r3
20000a80:	f107 071c 	add.w	r7, r7, #28
20000a84:	46bd      	mov	sp, r7
20000a86:	bc80      	pop	{r7}
20000a88:	4770      	bx	lr
20000a8a:	bf00      	nop

20000a8c <NVIC_EnableIRQ>:
 *
 * Enable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
20000a8c:	b480      	push	{r7}
20000a8e:	b083      	sub	sp, #12
20000a90:	af00      	add	r7, sp, #0
20000a92:	4603      	mov	r3, r0
20000a94:	80fb      	strh	r3, [r7, #6]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
20000a96:	f24e 1300 	movw	r3, #57600	; 0xe100
20000a9a:	f2ce 0300 	movt	r3, #57344	; 0xe000
20000a9e:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
20000aa2:	ea4f 1252 	mov.w	r2, r2, lsr #5
20000aa6:	88f9      	ldrh	r1, [r7, #6]
20000aa8:	f001 011f 	and.w	r1, r1, #31
20000aac:	f04f 0001 	mov.w	r0, #1
20000ab0:	fa00 f101 	lsl.w	r1, r0, r1
20000ab4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20000ab8:	f107 070c 	add.w	r7, r7, #12
20000abc:	46bd      	mov	sp, r7
20000abe:	bc80      	pop	{r7}
20000ac0:	4770      	bx	lr
20000ac2:	bf00      	nop

20000ac4 <NVIC_ClearPendingIRQ>:
 *
 * Clear the pending bit for the specified interrupt. 
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
20000ac4:	b480      	push	{r7}
20000ac6:	b083      	sub	sp, #12
20000ac8:	af00      	add	r7, sp, #0
20000aca:	4603      	mov	r3, r0
20000acc:	80fb      	strh	r3, [r7, #6]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
20000ace:	f24e 1300 	movw	r3, #57600	; 0xe100
20000ad2:	f2ce 0300 	movt	r3, #57344	; 0xe000
20000ad6:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
20000ada:	ea4f 1252 	mov.w	r2, r2, lsr #5
20000ade:	88f9      	ldrh	r1, [r7, #6]
20000ae0:	f001 011f 	and.w	r1, r1, #31
20000ae4:	f04f 0001 	mov.w	r0, #1
20000ae8:	fa00 f101 	lsl.w	r1, r0, r1
20000aec:	f102 0260 	add.w	r2, r2, #96	; 0x60
20000af0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20000af4:	f107 070c 	add.w	r7, r7, #12
20000af8:	46bd      	mov	sp, r7
20000afa:	bc80      	pop	{r7}
20000afc:	4770      	bx	lr
20000afe:	bf00      	nop

20000b00 <MSS_GPIO_init>:
/*-------------------------------------------------------------------------*//**
 * MSS_GPIO_init
 * See "mss_gpio.h" for details of how to use this function.
 */
void MSS_GPIO_init( void )
{
20000b00:	b580      	push	{r7, lr}
20000b02:	b082      	sub	sp, #8
20000b04:	af00      	add	r7, sp, #0
    uint32_t i;
    
    /* reset MSS GPIO hardware */
    SYSREG->SOFT_RST_CR |= SYSREG_GPIO_SOFTRESET_MASK;
20000b06:	f242 0300 	movw	r3, #8192	; 0x2000
20000b0a:	f2ce 0304 	movt	r3, #57348	; 0xe004
20000b0e:	f242 0200 	movw	r2, #8192	; 0x2000
20000b12:	f2ce 0204 	movt	r2, #57348	; 0xe004
20000b16:	6b12      	ldr	r2, [r2, #48]	; 0x30
20000b18:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
20000b1c:	631a      	str	r2, [r3, #48]	; 0x30
    /* Clear any previously pended MSS GPIO interrupt */
    for ( i = 0U; i < NB_OF_GPIO; ++i )
20000b1e:	f04f 0300 	mov.w	r3, #0
20000b22:	607b      	str	r3, [r7, #4]
20000b24:	e00e      	b.n	20000b44 <MSS_GPIO_init+0x44>
    {
        NVIC_ClearPendingIRQ( g_gpio_irqn_lut[i] );
20000b26:	687a      	ldr	r2, [r7, #4]
20000b28:	f242 2318 	movw	r3, #8728	; 0x2218
20000b2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000b30:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
20000b34:	b21b      	sxth	r3, r3
20000b36:	4618      	mov	r0, r3
20000b38:	f7ff ffc4 	bl	20000ac4 <NVIC_ClearPendingIRQ>
    uint32_t i;
    
    /* reset MSS GPIO hardware */
    SYSREG->SOFT_RST_CR |= SYSREG_GPIO_SOFTRESET_MASK;
    /* Clear any previously pended MSS GPIO interrupt */
    for ( i = 0U; i < NB_OF_GPIO; ++i )
20000b3c:	687b      	ldr	r3, [r7, #4]
20000b3e:	f103 0301 	add.w	r3, r3, #1
20000b42:	607b      	str	r3, [r7, #4]
20000b44:	687b      	ldr	r3, [r7, #4]
20000b46:	2b1f      	cmp	r3, #31
20000b48:	d9ed      	bls.n	20000b26 <MSS_GPIO_init+0x26>
    {
        NVIC_ClearPendingIRQ( g_gpio_irqn_lut[i] );
    }
    /* Take MSS GPIO hardware out of reset. */
    SYSREG->SOFT_RST_CR &= ~SYSREG_GPIO_SOFTRESET_MASK;
20000b4a:	f242 0300 	movw	r3, #8192	; 0x2000
20000b4e:	f2ce 0304 	movt	r3, #57348	; 0xe004
20000b52:	f242 0200 	movw	r2, #8192	; 0x2000
20000b56:	f2ce 0204 	movt	r2, #57348	; 0xe004
20000b5a:	6b12      	ldr	r2, [r2, #48]	; 0x30
20000b5c:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
20000b60:	631a      	str	r2, [r3, #48]	; 0x30
}
20000b62:	f107 0708 	add.w	r7, r7, #8
20000b66:	46bd      	mov	sp, r7
20000b68:	bd80      	pop	{r7, pc}
20000b6a:	bf00      	nop

20000b6c <MSS_GPIO_config>:
void MSS_GPIO_config
(
    mss_gpio_id_t port_id,
    uint32_t config
)
{
20000b6c:	b480      	push	{r7}
20000b6e:	b085      	sub	sp, #20
20000b70:	af00      	add	r7, sp, #0
20000b72:	4603      	mov	r3, r0
20000b74:	6039      	str	r1, [r7, #0]
20000b76:	71fb      	strb	r3, [r7, #7]
    uint32_t gpio_idx = (uint32_t)port_id;
20000b78:	79fb      	ldrb	r3, [r7, #7]
20000b7a:	60fb      	str	r3, [r7, #12]
    
    ASSERT( gpio_idx < NB_OF_GPIO );
20000b7c:	68fb      	ldr	r3, [r7, #12]
20000b7e:	2b1f      	cmp	r3, #31
20000b80:	d900      	bls.n	20000b84 <MSS_GPIO_config+0x18>
20000b82:	be00      	bkpt	0x0000

    if ( gpio_idx < NB_OF_GPIO )
20000b84:	68fb      	ldr	r3, [r7, #12]
20000b86:	2b1f      	cmp	r3, #31
20000b88:	d808      	bhi.n	20000b9c <MSS_GPIO_config+0x30>
    {
        *(g_config_reg_lut[gpio_idx]) = config;
20000b8a:	68fa      	ldr	r2, [r7, #12]
20000b8c:	f242 1398 	movw	r3, #8600	; 0x2198
20000b90:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000b94:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
20000b98:	683a      	ldr	r2, [r7, #0]
20000b9a:	601a      	str	r2, [r3, #0]
    }
}
20000b9c:	f107 0714 	add.w	r7, r7, #20
20000ba0:	46bd      	mov	sp, r7
20000ba2:	bc80      	pop	{r7}
20000ba4:	4770      	bx	lr
20000ba6:	bf00      	nop

20000ba8 <MSS_GPIO_set_output>:
void MSS_GPIO_set_output
(
    mss_gpio_id_t       port_id,
    uint8_t             value
)
{
20000ba8:	b480      	push	{r7}
20000baa:	b085      	sub	sp, #20
20000bac:	af00      	add	r7, sp, #0
20000bae:	4602      	mov	r2, r0
20000bb0:	460b      	mov	r3, r1
20000bb2:	71fa      	strb	r2, [r7, #7]
20000bb4:	71bb      	strb	r3, [r7, #6]
    uint32_t gpio_idx = (uint32_t)port_id;
20000bb6:	79fb      	ldrb	r3, [r7, #7]
20000bb8:	60fb      	str	r3, [r7, #12]
    
    ASSERT( gpio_idx < NB_OF_GPIO );
20000bba:	68fb      	ldr	r3, [r7, #12]
20000bbc:	2b1f      	cmp	r3, #31
20000bbe:	d900      	bls.n	20000bc2 <MSS_GPIO_set_output+0x1a>
20000bc0:	be00      	bkpt	0x0000
    
    if ( gpio_idx < NB_OF_GPIO )
20000bc2:	68fb      	ldr	r3, [r7, #12]
20000bc4:	2b1f      	cmp	r3, #31
20000bc6:	d809      	bhi.n	20000bdc <MSS_GPIO_set_output+0x34>
    {
        GPIO_BITBAND->GPIO_OUT[gpio_idx] = (uint32_t)value;
20000bc8:	f240 0300 	movw	r3, #0
20000bcc:	f2c4 2326 	movt	r3, #16934	; 0x4226
20000bd0:	68fa      	ldr	r2, [r7, #12]
20000bd2:	79b9      	ldrb	r1, [r7, #6]
20000bd4:	f502 6288 	add.w	r2, r2, #1088	; 0x440
20000bd8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    }
}
20000bdc:	f107 0714 	add.w	r7, r7, #20
20000be0:	46bd      	mov	sp, r7
20000be2:	bc80      	pop	{r7}
20000be4:	4770      	bx	lr
20000be6:	bf00      	nop

20000be8 <MSS_GPIO_drive_inout>:
void MSS_GPIO_drive_inout
(
    mss_gpio_id_t port_id,
    mss_gpio_inout_state_t inout_state
)
{
20000be8:	b480      	push	{r7}
20000bea:	b087      	sub	sp, #28
20000bec:	af00      	add	r7, sp, #0
20000bee:	4602      	mov	r2, r0
20000bf0:	460b      	mov	r3, r1
20000bf2:	71fa      	strb	r2, [r7, #7]
20000bf4:	71bb      	strb	r3, [r7, #6]
    uint32_t outputs_state;
    uint32_t config;
    uint32_t gpio_idx = (uint32_t)port_id;
20000bf6:	79fb      	ldrb	r3, [r7, #7]
20000bf8:	617b      	str	r3, [r7, #20]
    
    ASSERT( gpio_idx < NB_OF_GPIO );
20000bfa:	697b      	ldr	r3, [r7, #20]
20000bfc:	2b1f      	cmp	r3, #31
20000bfe:	d900      	bls.n	20000c02 <MSS_GPIO_drive_inout+0x1a>
20000c00:	be00      	bkpt	0x0000
    
    if ( gpio_idx < NB_OF_GPIO )
20000c02:	697b      	ldr	r3, [r7, #20]
20000c04:	2b1f      	cmp	r3, #31
20000c06:	d87d      	bhi.n	20000d04 <MSS_GPIO_drive_inout+0x11c>
    {
        switch( inout_state )
20000c08:	79bb      	ldrb	r3, [r7, #6]
20000c0a:	2b01      	cmp	r3, #1
20000c0c:	d004      	beq.n	20000c18 <MSS_GPIO_drive_inout+0x30>
20000c0e:	2b02      	cmp	r3, #2
20000c10:	d060      	beq.n	20000cd4 <MSS_GPIO_drive_inout+0xec>
20000c12:	2b00      	cmp	r3, #0
20000c14:	d02e      	beq.n	20000c74 <MSS_GPIO_drive_inout+0x8c>
20000c16:	e074      	b.n	20000d02 <MSS_GPIO_drive_inout+0x11a>
        {
        case MSS_GPIO_DRIVE_HIGH:
            /* Set output high */
            outputs_state = GPIO->GPIO_OUT;
20000c18:	f243 0300 	movw	r3, #12288	; 0x3000
20000c1c:	f2c4 0301 	movt	r3, #16385	; 0x4001
20000c20:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20000c24:	60fb      	str	r3, [r7, #12]
            outputs_state |= (uint32_t)1 << gpio_idx;
20000c26:	697b      	ldr	r3, [r7, #20]
20000c28:	f04f 0201 	mov.w	r2, #1
20000c2c:	fa02 f303 	lsl.w	r3, r2, r3
20000c30:	68fa      	ldr	r2, [r7, #12]
20000c32:	ea42 0303 	orr.w	r3, r2, r3
20000c36:	60fb      	str	r3, [r7, #12]
            GPIO->GPIO_OUT = outputs_state;
20000c38:	f243 0300 	movw	r3, #12288	; 0x3000
20000c3c:	f2c4 0301 	movt	r3, #16385	; 0x4001
20000c40:	68fa      	ldr	r2, [r7, #12]
20000c42:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
            /* Enable output buffer */
            config = *(g_config_reg_lut[gpio_idx]);
20000c46:	697a      	ldr	r2, [r7, #20]
20000c48:	f242 1398 	movw	r3, #8600	; 0x2198
20000c4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000c50:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
20000c54:	681b      	ldr	r3, [r3, #0]
20000c56:	613b      	str	r3, [r7, #16]
            config |= OUTPUT_BUFFER_ENABLE_MASK;
20000c58:	693b      	ldr	r3, [r7, #16]
20000c5a:	f043 0304 	orr.w	r3, r3, #4
20000c5e:	613b      	str	r3, [r7, #16]
            *(g_config_reg_lut[gpio_idx]) = config;
20000c60:	697a      	ldr	r2, [r7, #20]
20000c62:	f242 1398 	movw	r3, #8600	; 0x2198
20000c66:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000c6a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
20000c6e:	693a      	ldr	r2, [r7, #16]
20000c70:	601a      	str	r2, [r3, #0]
            break;
20000c72:	e047      	b.n	20000d04 <MSS_GPIO_drive_inout+0x11c>
            
        case MSS_GPIO_DRIVE_LOW:
            /* Set output low */
            outputs_state = GPIO->GPIO_OUT;
20000c74:	f243 0300 	movw	r3, #12288	; 0x3000
20000c78:	f2c4 0301 	movt	r3, #16385	; 0x4001
20000c7c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20000c80:	60fb      	str	r3, [r7, #12]
            outputs_state &= ~((uint32_t)((uint32_t)1 << gpio_idx));
20000c82:	697b      	ldr	r3, [r7, #20]
20000c84:	f04f 0201 	mov.w	r2, #1
20000c88:	fa02 f303 	lsl.w	r3, r2, r3
20000c8c:	ea6f 0303 	mvn.w	r3, r3
20000c90:	68fa      	ldr	r2, [r7, #12]
20000c92:	ea02 0303 	and.w	r3, r2, r3
20000c96:	60fb      	str	r3, [r7, #12]
            GPIO->GPIO_OUT = outputs_state;
20000c98:	f243 0300 	movw	r3, #12288	; 0x3000
20000c9c:	f2c4 0301 	movt	r3, #16385	; 0x4001
20000ca0:	68fa      	ldr	r2, [r7, #12]
20000ca2:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
            /* Enable output buffer */
            config = *(g_config_reg_lut[gpio_idx]);
20000ca6:	697a      	ldr	r2, [r7, #20]
20000ca8:	f242 1398 	movw	r3, #8600	; 0x2198
20000cac:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000cb0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
20000cb4:	681b      	ldr	r3, [r3, #0]
20000cb6:	613b      	str	r3, [r7, #16]
            config |= OUTPUT_BUFFER_ENABLE_MASK;
20000cb8:	693b      	ldr	r3, [r7, #16]
20000cba:	f043 0304 	orr.w	r3, r3, #4
20000cbe:	613b      	str	r3, [r7, #16]
            *(g_config_reg_lut[gpio_idx]) = config;
20000cc0:	697a      	ldr	r2, [r7, #20]
20000cc2:	f242 1398 	movw	r3, #8600	; 0x2198
20000cc6:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000cca:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
20000cce:	693a      	ldr	r2, [r7, #16]
20000cd0:	601a      	str	r2, [r3, #0]
            break;
20000cd2:	e017      	b.n	20000d04 <MSS_GPIO_drive_inout+0x11c>
            
        case MSS_GPIO_HIGH_Z:
            /* Disable output buffer */
            config = *(g_config_reg_lut[gpio_idx]);
20000cd4:	697a      	ldr	r2, [r7, #20]
20000cd6:	f242 1398 	movw	r3, #8600	; 0x2198
20000cda:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000cde:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
20000ce2:	681b      	ldr	r3, [r3, #0]
20000ce4:	613b      	str	r3, [r7, #16]
            config &= ~OUTPUT_BUFFER_ENABLE_MASK;
20000ce6:	693b      	ldr	r3, [r7, #16]
20000ce8:	f023 0304 	bic.w	r3, r3, #4
20000cec:	613b      	str	r3, [r7, #16]
            *(g_config_reg_lut[gpio_idx]) = config;
20000cee:	697a      	ldr	r2, [r7, #20]
20000cf0:	f242 1398 	movw	r3, #8600	; 0x2198
20000cf4:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000cf8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
20000cfc:	693a      	ldr	r2, [r7, #16]
20000cfe:	601a      	str	r2, [r3, #0]
            break;
20000d00:	e000      	b.n	20000d04 <MSS_GPIO_drive_inout+0x11c>
            
        default:
            ASSERT(0);
20000d02:	be00      	bkpt	0x0000
            break;
        }
    }
}
20000d04:	f107 071c 	add.w	r7, r7, #28
20000d08:	46bd      	mov	sp, r7
20000d0a:	bc80      	pop	{r7}
20000d0c:	4770      	bx	lr
20000d0e:	bf00      	nop

20000d10 <MSS_GPIO_enable_irq>:
 */
void MSS_GPIO_enable_irq
(
    mss_gpio_id_t port_id
)
{
20000d10:	b580      	push	{r7, lr}
20000d12:	b084      	sub	sp, #16
20000d14:	af00      	add	r7, sp, #0
20000d16:	4603      	mov	r3, r0
20000d18:	71fb      	strb	r3, [r7, #7]
    uint32_t cfg_value;
    uint32_t gpio_idx = (uint32_t)port_id;
20000d1a:	79fb      	ldrb	r3, [r7, #7]
20000d1c:	60fb      	str	r3, [r7, #12]
    
    ASSERT( gpio_idx < NB_OF_GPIO );
20000d1e:	68fb      	ldr	r3, [r7, #12]
20000d20:	2b1f      	cmp	r3, #31
20000d22:	d900      	bls.n	20000d26 <MSS_GPIO_enable_irq+0x16>
20000d24:	be00      	bkpt	0x0000
    
    if ( gpio_idx < NB_OF_GPIO )
20000d26:	68fb      	ldr	r3, [r7, #12]
20000d28:	2b1f      	cmp	r3, #31
20000d2a:	d81e      	bhi.n	20000d6a <MSS_GPIO_enable_irq+0x5a>
    {
        cfg_value = *(g_config_reg_lut[gpio_idx]);
20000d2c:	68fa      	ldr	r2, [r7, #12]
20000d2e:	f242 1398 	movw	r3, #8600	; 0x2198
20000d32:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000d36:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
20000d3a:	681b      	ldr	r3, [r3, #0]
20000d3c:	60bb      	str	r3, [r7, #8]
        *(g_config_reg_lut[gpio_idx]) = (cfg_value | GPIO_INT_ENABLE_MASK);
20000d3e:	68fa      	ldr	r2, [r7, #12]
20000d40:	f242 1398 	movw	r3, #8600	; 0x2198
20000d44:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000d48:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
20000d4c:	68ba      	ldr	r2, [r7, #8]
20000d4e:	f042 0208 	orr.w	r2, r2, #8
20000d52:	601a      	str	r2, [r3, #0]
        NVIC_EnableIRQ( g_gpio_irqn_lut[gpio_idx] );
20000d54:	68fa      	ldr	r2, [r7, #12]
20000d56:	f242 2318 	movw	r3, #8728	; 0x2218
20000d5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000d5e:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
20000d62:	b21b      	sxth	r3, r3
20000d64:	4618      	mov	r0, r3
20000d66:	f7ff fe91 	bl	20000a8c <NVIC_EnableIRQ>
    }
}
20000d6a:	f107 0710 	add.w	r7, r7, #16
20000d6e:	46bd      	mov	sp, r7
20000d70:	bd80      	pop	{r7, pc}
20000d72:	bf00      	nop

20000d74 <MSS_GPIO_disable_irq>:
 */
void MSS_GPIO_disable_irq
(
    mss_gpio_id_t port_id
)
{
20000d74:	b480      	push	{r7}
20000d76:	b085      	sub	sp, #20
20000d78:	af00      	add	r7, sp, #0
20000d7a:	4603      	mov	r3, r0
20000d7c:	71fb      	strb	r3, [r7, #7]
    uint32_t cfg_value;
    uint32_t gpio_idx = (uint32_t)port_id;
20000d7e:	79fb      	ldrb	r3, [r7, #7]
20000d80:	60fb      	str	r3, [r7, #12]
    
    ASSERT( gpio_idx < NB_OF_GPIO );
20000d82:	68fb      	ldr	r3, [r7, #12]
20000d84:	2b1f      	cmp	r3, #31
20000d86:	d900      	bls.n	20000d8a <MSS_GPIO_disable_irq+0x16>
20000d88:	be00      	bkpt	0x0000

    if ( gpio_idx < NB_OF_GPIO )
20000d8a:	68fb      	ldr	r3, [r7, #12]
20000d8c:	2b1f      	cmp	r3, #31
20000d8e:	d813      	bhi.n	20000db8 <MSS_GPIO_disable_irq+0x44>
    {
        cfg_value = *(g_config_reg_lut[gpio_idx]);
20000d90:	68fa      	ldr	r2, [r7, #12]
20000d92:	f242 1398 	movw	r3, #8600	; 0x2198
20000d96:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000d9a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
20000d9e:	681b      	ldr	r3, [r3, #0]
20000da0:	60bb      	str	r3, [r7, #8]
        *(g_config_reg_lut[gpio_idx]) = (cfg_value & ~GPIO_INT_ENABLE_MASK);
20000da2:	68fa      	ldr	r2, [r7, #12]
20000da4:	f242 1398 	movw	r3, #8600	; 0x2198
20000da8:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000dac:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
20000db0:	68ba      	ldr	r2, [r7, #8]
20000db2:	f022 0208 	bic.w	r2, r2, #8
20000db6:	601a      	str	r2, [r3, #0]
    }
}
20000db8:	f107 0714 	add.w	r7, r7, #20
20000dbc:	46bd      	mov	sp, r7
20000dbe:	bc80      	pop	{r7}
20000dc0:	4770      	bx	lr
20000dc2:	bf00      	nop

20000dc4 <MSS_GPIO_clear_irq>:
 */
void MSS_GPIO_clear_irq
(
    mss_gpio_id_t port_id
)
{
20000dc4:	b580      	push	{r7, lr}
20000dc6:	b084      	sub	sp, #16
20000dc8:	af00      	add	r7, sp, #0
20000dca:	4603      	mov	r3, r0
20000dcc:	71fb      	strb	r3, [r7, #7]
    uint32_t gpio_idx = (uint32_t)port_id;
20000dce:	79fb      	ldrb	r3, [r7, #7]
20000dd0:	60fb      	str	r3, [r7, #12]
    
    ASSERT( gpio_idx < NB_OF_GPIO );
20000dd2:	68fb      	ldr	r3, [r7, #12]
20000dd4:	2b1f      	cmp	r3, #31
20000dd6:	d900      	bls.n	20000dda <MSS_GPIO_clear_irq+0x16>
20000dd8:	be00      	bkpt	0x0000
    
    if ( gpio_idx < NB_OF_GPIO )
20000dda:	68fb      	ldr	r3, [r7, #12]
20000ddc:	2b1f      	cmp	r3, #31
20000dde:	d815      	bhi.n	20000e0c <MSS_GPIO_clear_irq+0x48>
    {
        GPIO->GPIO_IRQ = ((uint32_t)1) << gpio_idx;
20000de0:	f243 0300 	movw	r3, #12288	; 0x3000
20000de4:	f2c4 0301 	movt	r3, #16385	; 0x4001
20000de8:	68fa      	ldr	r2, [r7, #12]
20000dea:	f04f 0101 	mov.w	r1, #1
20000dee:	fa01 f202 	lsl.w	r2, r1, r2
20000df2:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
        NVIC_ClearPendingIRQ( g_gpio_irqn_lut[gpio_idx] );
20000df6:	68fa      	ldr	r2, [r7, #12]
20000df8:	f242 2318 	movw	r3, #8728	; 0x2218
20000dfc:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000e00:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
20000e04:	b21b      	sxth	r3, r3
20000e06:	4618      	mov	r0, r3
20000e08:	f7ff fe5c 	bl	20000ac4 <NVIC_ClearPendingIRQ>
    }
}
20000e0c:	f107 0710 	add.w	r7, r7, #16
20000e10:	46bd      	mov	sp, r7
20000e12:	bd80      	pop	{r7, pc}

20000e14 <UART_init>:
	UART_instance_t * this_uart,
	addr_t base_addr,
	uint16_t baud_value,
	uint8_t line_config
)
{
20000e14:	b580      	push	{r7, lr}
20000e16:	b0aa      	sub	sp, #168	; 0xa8
20000e18:	af00      	add	r7, sp, #0
20000e1a:	60f8      	str	r0, [r7, #12]
20000e1c:	60b9      	str	r1, [r7, #8]
20000e1e:	80fa      	strh	r2, [r7, #6]
20000e20:	717b      	strb	r3, [r7, #5]
    uint8_t rx_full;
    
	HAL_ASSERT( this_uart != NULL_INSTANCE )
20000e22:	68fb      	ldr	r3, [r7, #12]
20000e24:	2b00      	cmp	r3, #0
20000e26:	d117      	bne.n	20000e58 <UART_init+0x44>
20000e28:	f242 2358 	movw	r3, #8792	; 0x2258
20000e2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000e30:	f107 0c88 	add.w	ip, r7, #136	; 0x88
20000e34:	469e      	mov	lr, r3
20000e36:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
20000e3a:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
20000e3e:	e89e 0007 	ldmia.w	lr, {r0, r1, r2}
20000e42:	e8ac 0003 	stmia.w	ip!, {r0, r1}
20000e46:	f8ac 2000 	strh.w	r2, [ip]
20000e4a:	f107 0388 	add.w	r3, r7, #136	; 0x88
20000e4e:	4618      	mov	r0, r3
20000e50:	f04f 0130 	mov.w	r1, #48	; 0x30
20000e54:	f000 fb8e 	bl	20001574 <HAL_assert_fail>
	HAL_ASSERT( line_config <= MAX_LINE_CONFIG )
20000e58:	797b      	ldrb	r3, [r7, #5]
20000e5a:	2b07      	cmp	r3, #7
20000e5c:	d917      	bls.n	20000e8e <UART_init+0x7a>
20000e5e:	f242 2358 	movw	r3, #8792	; 0x2258
20000e62:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000e66:	f107 0c6c 	add.w	ip, r7, #108	; 0x6c
20000e6a:	469e      	mov	lr, r3
20000e6c:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
20000e70:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
20000e74:	e89e 0007 	ldmia.w	lr, {r0, r1, r2}
20000e78:	e8ac 0003 	stmia.w	ip!, {r0, r1}
20000e7c:	f8ac 2000 	strh.w	r2, [ip]
20000e80:	f107 036c 	add.w	r3, r7, #108	; 0x6c
20000e84:	4618      	mov	r0, r3
20000e86:	f04f 0131 	mov.w	r1, #49	; 0x31
20000e8a:	f000 fb73 	bl	20001574 <HAL_assert_fail>
    HAL_ASSERT( baud_value <= MAX_BAUD_VALUE )
20000e8e:	88fa      	ldrh	r2, [r7, #6]
20000e90:	f641 73ff 	movw	r3, #8191	; 0x1fff
20000e94:	429a      	cmp	r2, r3
20000e96:	d917      	bls.n	20000ec8 <UART_init+0xb4>
20000e98:	f242 2358 	movw	r3, #8792	; 0x2258
20000e9c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000ea0:	f107 0c50 	add.w	ip, r7, #80	; 0x50
20000ea4:	469e      	mov	lr, r3
20000ea6:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
20000eaa:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
20000eae:	e89e 0007 	ldmia.w	lr, {r0, r1, r2}
20000eb2:	e8ac 0003 	stmia.w	ip!, {r0, r1}
20000eb6:	f8ac 2000 	strh.w	r2, [ip]
20000eba:	f107 0350 	add.w	r3, r7, #80	; 0x50
20000ebe:	4618      	mov	r0, r3
20000ec0:	f04f 0132 	mov.w	r1, #50	; 0x32
20000ec4:	f000 fb56 	bl	20001574 <HAL_assert_fail>

    if( ( this_uart != NULL_INSTANCE ) &&
20000ec8:	68fb      	ldr	r3, [r7, #12]
20000eca:	2b00      	cmp	r3, #0
20000ecc:	f000 80b5 	beq.w	2000103a <UART_init+0x226>
20000ed0:	797b      	ldrb	r3, [r7, #5]
20000ed2:	2b07      	cmp	r3, #7
20000ed4:	f200 80b1 	bhi.w	2000103a <UART_init+0x226>
20000ed8:	88fa      	ldrh	r2, [r7, #6]
20000eda:	f641 73ff 	movw	r3, #8191	; 0x1fff
20000ede:	429a      	cmp	r2, r3
20000ee0:	f200 80ab 	bhi.w	2000103a <UART_init+0x226>
        ( baud_value <= MAX_BAUD_VALUE ) )
    {
        /*
         * Store lower 8-bits of baud value in CTRL1.
         */
        HAL_set_8bit_reg( base_addr, CTRL1, (uint_fast8_t)(baud_value &
20000ee4:	68bb      	ldr	r3, [r7, #8]
20000ee6:	f103 0208 	add.w	r2, r3, #8
20000eea:	88fb      	ldrh	r3, [r7, #6]
20000eec:	f003 03ff 	and.w	r3, r3, #255	; 0xff
20000ef0:	4610      	mov	r0, r2
20000ef2:	4619      	mov	r1, r3
20000ef4:	f000 fb82 	bl	200015fc <HW_set_8bit_reg>
    
        /*
         * Extract higher 5-bits of baud value and store in higher 5-bits 
         * of CTRL2, along with line configuration in lower 3 three bits.
         */
        HAL_set_8bit_reg( base_addr, CTRL2, (uint_fast8_t)line_config | 
20000ef8:	68bb      	ldr	r3, [r7, #8]
20000efa:	f103 020c 	add.w	r2, r3, #12
20000efe:	7979      	ldrb	r1, [r7, #5]
                                           (uint_fast8_t)((baud_value &
                                   BAUDVALUE_MSB) >> BAUDVALUE_SHIFT ) );
20000f00:	88fb      	ldrh	r3, [r7, #6]
20000f02:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
20000f06:	ea4f 1363 	mov.w	r3, r3, asr #5
    
        /*
         * Extract higher 5-bits of baud value and store in higher 5-bits 
         * of CTRL2, along with line configuration in lower 3 three bits.
         */
        HAL_set_8bit_reg( base_addr, CTRL2, (uint_fast8_t)line_config | 
20000f0a:	ea41 0303 	orr.w	r3, r1, r3
20000f0e:	4610      	mov	r0, r2
20000f10:	4619      	mov	r1, r3
20000f12:	f000 fb73 	bl	200015fc <HW_set_8bit_reg>
                                           (uint_fast8_t)((baud_value &
                                   BAUDVALUE_MSB) >> BAUDVALUE_SHIFT ) );
    
        this_uart->base_address = base_addr;
20000f16:	68fb      	ldr	r3, [r7, #12]
20000f18:	68ba      	ldr	r2, [r7, #8]
20000f1a:	601a      	str	r2, [r3, #0]
#ifndef NDEBUG
        {
            uint8_t  config;
            uint8_t  temp;
            uint16_t baud_val;
            baud_val = HAL_get_8bit_reg( this_uart->base_address, CTRL1 );
20000f1c:	68fb      	ldr	r3, [r7, #12]
20000f1e:	681b      	ldr	r3, [r3, #0]
20000f20:	f103 0308 	add.w	r3, r3, #8
20000f24:	4618      	mov	r0, r3
20000f26:	f000 fb6b 	bl	20001600 <HW_get_8bit_reg>
20000f2a:	4603      	mov	r3, r0
20000f2c:	f8a7 30a6 	strh.w	r3, [r7, #166]	; 0xa6
            config =  HAL_get_8bit_reg( this_uart->base_address, CTRL2 );
20000f30:	68fb      	ldr	r3, [r7, #12]
20000f32:	681b      	ldr	r3, [r3, #0]
20000f34:	f103 030c 	add.w	r3, r3, #12
20000f38:	4618      	mov	r0, r3
20000f3a:	f000 fb61 	bl	20001600 <HW_get_8bit_reg>
20000f3e:	4603      	mov	r3, r0
20000f40:	f887 30a4 	strb.w	r3, [r7, #164]	; 0xa4
            /*
             * To resolve operator precedence between & and <<
             */
            temp =  ( config  &  (uint8_t)(CTRL2_BAUDVALUE_MASK ) );
20000f44:	f897 30a4 	ldrb.w	r3, [r7, #164]	; 0xa4
20000f48:	f023 0307 	bic.w	r3, r3, #7
20000f4c:	f887 30a5 	strb.w	r3, [r7, #165]	; 0xa5
            baud_val |= (uint16_t)( (uint16_t)(temp) << BAUDVALUE_SHIFT );
20000f50:	f897 30a5 	ldrb.w	r3, [r7, #165]	; 0xa5
20000f54:	ea4f 1343 	mov.w	r3, r3, lsl #5
20000f58:	b29a      	uxth	r2, r3
20000f5a:	f8b7 30a6 	ldrh.w	r3, [r7, #166]	; 0xa6
20000f5e:	ea42 0303 	orr.w	r3, r2, r3
20000f62:	f8a7 30a6 	strh.w	r3, [r7, #166]	; 0xa6
            config &= (uint8_t)(~CTRL2_BAUDVALUE_MASK);
20000f66:	f897 30a4 	ldrb.w	r3, [r7, #164]	; 0xa4
20000f6a:	f003 0307 	and.w	r3, r3, #7
20000f6e:	f887 30a4 	strb.w	r3, [r7, #164]	; 0xa4
            HAL_ASSERT( baud_val == baud_value );
20000f72:	f8b7 20a6 	ldrh.w	r2, [r7, #166]	; 0xa6
20000f76:	88fb      	ldrh	r3, [r7, #6]
20000f78:	429a      	cmp	r2, r3
20000f7a:	d017      	beq.n	20000fac <UART_init+0x198>
20000f7c:	f242 2358 	movw	r3, #8792	; 0x2258
20000f80:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000f84:	f107 0c34 	add.w	ip, r7, #52	; 0x34
20000f88:	469e      	mov	lr, r3
20000f8a:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
20000f8e:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
20000f92:	e89e 0007 	ldmia.w	lr, {r0, r1, r2}
20000f96:	e8ac 0003 	stmia.w	ip!, {r0, r1}
20000f9a:	f8ac 2000 	strh.w	r2, [ip]
20000f9e:	f107 0334 	add.w	r3, r7, #52	; 0x34
20000fa2:	4618      	mov	r0, r3
20000fa4:	f04f 0154 	mov.w	r1, #84	; 0x54
20000fa8:	f000 fae4 	bl	20001574 <HAL_assert_fail>
            HAL_ASSERT( config == line_config );
20000fac:	f897 20a4 	ldrb.w	r2, [r7, #164]	; 0xa4
20000fb0:	797b      	ldrb	r3, [r7, #5]
20000fb2:	429a      	cmp	r2, r3
20000fb4:	d017      	beq.n	20000fe6 <UART_init+0x1d2>
20000fb6:	f242 2358 	movw	r3, #8792	; 0x2258
20000fba:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000fbe:	f107 0c18 	add.w	ip, r7, #24
20000fc2:	469e      	mov	lr, r3
20000fc4:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
20000fc8:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
20000fcc:	e89e 0007 	ldmia.w	lr, {r0, r1, r2}
20000fd0:	e8ac 0003 	stmia.w	ip!, {r0, r1}
20000fd4:	f8ac 2000 	strh.w	r2, [ip]
20000fd8:	f107 0318 	add.w	r3, r7, #24
20000fdc:	4618      	mov	r0, r3
20000fde:	f04f 0155 	mov.w	r1, #85	; 0x55
20000fe2:	f000 fac7 	bl	20001574 <HAL_assert_fail>
        
        /*
         * Flush the receive FIFO of data that may have been received before the
         * driver was initialized.
         */
        rx_full = HAL_get_8bit_reg( this_uart->base_address, STATUS ) &
20000fe6:	68fb      	ldr	r3, [r7, #12]
20000fe8:	681b      	ldr	r3, [r3, #0]
20000fea:	f103 0310 	add.w	r3, r3, #16
20000fee:	4618      	mov	r0, r3
20000ff0:	f000 fb06 	bl	20001600 <HW_get_8bit_reg>
20000ff4:	4603      	mov	r3, r0
20000ff6:	f003 0302 	and.w	r3, r3, #2
20000ffa:	f887 30a3 	strb.w	r3, [r7, #163]	; 0xa3
        		                                    STATUS_RXFULL_MASK;
        while ( rx_full )
20000ffe:	e014      	b.n	2000102a <UART_init+0x216>
        {
            volatile uint8_t rx_byte;
            rx_byte = HAL_get_8bit_reg( this_uart->base_address, RXDATA );
20001000:	68fb      	ldr	r3, [r7, #12]
20001002:	681b      	ldr	r3, [r3, #0]
20001004:	f103 0304 	add.w	r3, r3, #4
20001008:	4618      	mov	r0, r3
2000100a:	f000 faf9 	bl	20001600 <HW_get_8bit_reg>
2000100e:	4603      	mov	r3, r0
20001010:	75fb      	strb	r3, [r7, #23]
            rx_full = HAL_get_8bit_reg( this_uart->base_address, STATUS ) &
20001012:	68fb      	ldr	r3, [r7, #12]
20001014:	681b      	ldr	r3, [r3, #0]
20001016:	f103 0310 	add.w	r3, r3, #16
2000101a:	4618      	mov	r0, r3
2000101c:	f000 faf0 	bl	20001600 <HW_get_8bit_reg>
20001020:	4603      	mov	r3, r0
20001022:	f003 0302 	and.w	r3, r3, #2
20001026:	f887 30a3 	strb.w	r3, [r7, #163]	; 0xa3
         * Flush the receive FIFO of data that may have been received before the
         * driver was initialized.
         */
        rx_full = HAL_get_8bit_reg( this_uart->base_address, STATUS ) &
        		                                    STATUS_RXFULL_MASK;
        while ( rx_full )
2000102a:	f897 30a3 	ldrb.w	r3, [r7, #163]	; 0xa3
2000102e:	2b00      	cmp	r3, #0
20001030:	d1e6      	bne.n	20001000 <UART_init+0x1ec>
        }

        /*
         * Clear status of the UART instance.
         */
        this_uart->status = (uint8_t)0;
20001032:	68fb      	ldr	r3, [r7, #12]
20001034:	f04f 0200 	mov.w	r2, #0
20001038:	711a      	strb	r2, [r3, #4]
    }
}
2000103a:	f107 07a8 	add.w	r7, r7, #168	; 0xa8
2000103e:	46bd      	mov	sp, r7
20001040:	bd80      	pop	{r7, pc}
20001042:	bf00      	nop

20001044 <UART_send>:
(
    UART_instance_t * this_uart,
    const uint8_t * tx_buffer,
    size_t tx_size
)
{
20001044:	b580      	push	{r7, lr}
20001046:	b09c      	sub	sp, #112	; 0x70
20001048:	af00      	add	r7, sp, #0
2000104a:	60f8      	str	r0, [r7, #12]
2000104c:	60b9      	str	r1, [r7, #8]
2000104e:	607a      	str	r2, [r7, #4]
	size_t char_idx;
    uint8_t tx_ready;

	HAL_ASSERT( this_uart != NULL_INSTANCE )
20001050:	68fb      	ldr	r3, [r7, #12]
20001052:	2b00      	cmp	r3, #0
20001054:	d117      	bne.n	20001086 <UART_send+0x42>
20001056:	f242 2358 	movw	r3, #8792	; 0x2258
2000105a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000105e:	f107 0c4c 	add.w	ip, r7, #76	; 0x4c
20001062:	469e      	mov	lr, r3
20001064:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
20001068:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
2000106c:	e89e 0007 	ldmia.w	lr, {r0, r1, r2}
20001070:	e8ac 0003 	stmia.w	ip!, {r0, r1}
20001074:	f8ac 2000 	strh.w	r2, [ip]
20001078:	f107 034c 	add.w	r3, r7, #76	; 0x4c
2000107c:	4618      	mov	r0, r3
2000107e:	f04f 017d 	mov.w	r1, #125	; 0x7d
20001082:	f000 fa77 	bl	20001574 <HAL_assert_fail>
	HAL_ASSERT( tx_buffer != NULL_BUFFER )
20001086:	68bb      	ldr	r3, [r7, #8]
20001088:	2b00      	cmp	r3, #0
2000108a:	d117      	bne.n	200010bc <UART_send+0x78>
2000108c:	f242 2358 	movw	r3, #8792	; 0x2258
20001090:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001094:	f107 0c30 	add.w	ip, r7, #48	; 0x30
20001098:	469e      	mov	lr, r3
2000109a:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
2000109e:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
200010a2:	e89e 0007 	ldmia.w	lr, {r0, r1, r2}
200010a6:	e8ac 0003 	stmia.w	ip!, {r0, r1}
200010aa:	f8ac 2000 	strh.w	r2, [ip]
200010ae:	f107 0330 	add.w	r3, r7, #48	; 0x30
200010b2:	4618      	mov	r0, r3
200010b4:	f04f 017e 	mov.w	r1, #126	; 0x7e
200010b8:	f000 fa5c 	bl	20001574 <HAL_assert_fail>
	HAL_ASSERT( tx_size > 0 )
200010bc:	687b      	ldr	r3, [r7, #4]
200010be:	2b00      	cmp	r3, #0
200010c0:	d117      	bne.n	200010f2 <UART_send+0xae>
200010c2:	f242 2358 	movw	r3, #8792	; 0x2258
200010c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200010ca:	f107 0c14 	add.w	ip, r7, #20
200010ce:	469e      	mov	lr, r3
200010d0:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
200010d4:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
200010d8:	e89e 0007 	ldmia.w	lr, {r0, r1, r2}
200010dc:	e8ac 0003 	stmia.w	ip!, {r0, r1}
200010e0:	f8ac 2000 	strh.w	r2, [ip]
200010e4:	f107 0314 	add.w	r3, r7, #20
200010e8:	4618      	mov	r0, r3
200010ea:	f04f 017f 	mov.w	r1, #127	; 0x7f
200010ee:	f000 fa41 	bl	20001574 <HAL_assert_fail>
      
    if( (this_uart != NULL_INSTANCE) &&
200010f2:	68fb      	ldr	r3, [r7, #12]
200010f4:	2b00      	cmp	r3, #0
200010f6:	d02b      	beq.n	20001150 <UART_send+0x10c>
200010f8:	68bb      	ldr	r3, [r7, #8]
200010fa:	2b00      	cmp	r3, #0
200010fc:	d028      	beq.n	20001150 <UART_send+0x10c>
200010fe:	687b      	ldr	r3, [r7, #4]
20001100:	2b00      	cmp	r3, #0
20001102:	d025      	beq.n	20001150 <UART_send+0x10c>
        (tx_buffer != NULL_BUFFER)   &&
        (tx_size > (size_t)0) )
    {
        for ( char_idx = (size_t)0; char_idx < tx_size; char_idx++ )
20001104:	f04f 0300 	mov.w	r3, #0
20001108:	66bb      	str	r3, [r7, #104]	; 0x68
2000110a:	e01d      	b.n	20001148 <UART_send+0x104>
        {
            /* Wait for UART to become ready to transmit. */
            do {
                tx_ready = HAL_get_8bit_reg( this_uart->base_address, STATUS ) &
2000110c:	68fb      	ldr	r3, [r7, #12]
2000110e:	681b      	ldr	r3, [r3, #0]
20001110:	f103 0310 	add.w	r3, r3, #16
20001114:	4618      	mov	r0, r3
20001116:	f000 fa73 	bl	20001600 <HW_get_8bit_reg>
2000111a:	4603      	mov	r3, r0
2000111c:	f003 0301 	and.w	r3, r3, #1
20001120:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
                		                                      STATUS_TXRDY_MASK;
            } while ( !tx_ready );
20001124:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
20001128:	2b00      	cmp	r3, #0
2000112a:	d0ef      	beq.n	2000110c <UART_send+0xc8>
            /* Send next character in the buffer. */
            HAL_set_8bit_reg( this_uart->base_address, TXDATA,
2000112c:	68fb      	ldr	r3, [r7, #12]
2000112e:	681a      	ldr	r2, [r3, #0]
            		          (uint_fast8_t)tx_buffer[char_idx] );
20001130:	68b9      	ldr	r1, [r7, #8]
20001132:	6ebb      	ldr	r3, [r7, #104]	; 0x68
20001134:	440b      	add	r3, r1
20001136:	781b      	ldrb	r3, [r3, #0]
            do {
                tx_ready = HAL_get_8bit_reg( this_uart->base_address, STATUS ) &
                		                                      STATUS_TXRDY_MASK;
            } while ( !tx_ready );
            /* Send next character in the buffer. */
            HAL_set_8bit_reg( this_uart->base_address, TXDATA,
20001138:	4610      	mov	r0, r2
2000113a:	4619      	mov	r1, r3
2000113c:	f000 fa5e 	bl	200015fc <HW_set_8bit_reg>
      
    if( (this_uart != NULL_INSTANCE) &&
        (tx_buffer != NULL_BUFFER)   &&
        (tx_size > (size_t)0) )
    {
        for ( char_idx = (size_t)0; char_idx < tx_size; char_idx++ )
20001140:	6ebb      	ldr	r3, [r7, #104]	; 0x68
20001142:	f103 0301 	add.w	r3, r3, #1
20001146:	66bb      	str	r3, [r7, #104]	; 0x68
20001148:	6eba      	ldr	r2, [r7, #104]	; 0x68
2000114a:	687b      	ldr	r3, [r7, #4]
2000114c:	429a      	cmp	r2, r3
2000114e:	d3dd      	bcc.n	2000110c <UART_send+0xc8>
            /* Send next character in the buffer. */
            HAL_set_8bit_reg( this_uart->base_address, TXDATA,
            		          (uint_fast8_t)tx_buffer[char_idx] );
        }
    }
}
20001150:	f107 0770 	add.w	r7, r7, #112	; 0x70
20001154:	46bd      	mov	sp, r7
20001156:	bd80      	pop	{r7, pc}

20001158 <UART_fill_tx_fifo>:
(
	UART_instance_t * this_uart,
	const uint8_t * tx_buffer,
	size_t tx_size
)
{
20001158:	b580      	push	{r7, lr}
2000115a:	b09a      	sub	sp, #104	; 0x68
2000115c:	af00      	add	r7, sp, #0
2000115e:	60f8      	str	r0, [r7, #12]
20001160:	60b9      	str	r1, [r7, #8]
20001162:	607a      	str	r2, [r7, #4]
    uint8_t tx_ready;
    size_t size_sent = 0u;
20001164:	f04f 0300 	mov.w	r3, #0
20001168:	667b      	str	r3, [r7, #100]	; 0x64
    
	HAL_ASSERT( this_uart != NULL_INSTANCE )
2000116a:	68fb      	ldr	r3, [r7, #12]
2000116c:	2b00      	cmp	r3, #0
2000116e:	d117      	bne.n	200011a0 <UART_fill_tx_fifo+0x48>
20001170:	f242 2358 	movw	r3, #8792	; 0x2258
20001174:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001178:	f107 0c48 	add.w	ip, r7, #72	; 0x48
2000117c:	469e      	mov	lr, r3
2000117e:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
20001182:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
20001186:	e89e 0007 	ldmia.w	lr, {r0, r1, r2}
2000118a:	e8ac 0003 	stmia.w	ip!, {r0, r1}
2000118e:	f8ac 2000 	strh.w	r2, [ip]
20001192:	f107 0348 	add.w	r3, r7, #72	; 0x48
20001196:	4618      	mov	r0, r3
20001198:	f04f 01a2 	mov.w	r1, #162	; 0xa2
2000119c:	f000 f9ea 	bl	20001574 <HAL_assert_fail>
	HAL_ASSERT( tx_buffer != NULL_BUFFER )
200011a0:	68bb      	ldr	r3, [r7, #8]
200011a2:	2b00      	cmp	r3, #0
200011a4:	d117      	bne.n	200011d6 <UART_fill_tx_fifo+0x7e>
200011a6:	f242 2358 	movw	r3, #8792	; 0x2258
200011aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
200011ae:	f107 0c2c 	add.w	ip, r7, #44	; 0x2c
200011b2:	469e      	mov	lr, r3
200011b4:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
200011b8:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
200011bc:	e89e 0007 	ldmia.w	lr, {r0, r1, r2}
200011c0:	e8ac 0003 	stmia.w	ip!, {r0, r1}
200011c4:	f8ac 2000 	strh.w	r2, [ip]
200011c8:	f107 032c 	add.w	r3, r7, #44	; 0x2c
200011cc:	4618      	mov	r0, r3
200011ce:	f04f 01a3 	mov.w	r1, #163	; 0xa3
200011d2:	f000 f9cf 	bl	20001574 <HAL_assert_fail>
	HAL_ASSERT( tx_size > 0 )
200011d6:	687b      	ldr	r3, [r7, #4]
200011d8:	2b00      	cmp	r3, #0
200011da:	d117      	bne.n	2000120c <UART_fill_tx_fifo+0xb4>
200011dc:	f242 2358 	movw	r3, #8792	; 0x2258
200011e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200011e4:	f107 0c10 	add.w	ip, r7, #16
200011e8:	469e      	mov	lr, r3
200011ea:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
200011ee:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
200011f2:	e89e 0007 	ldmia.w	lr, {r0, r1, r2}
200011f6:	e8ac 0003 	stmia.w	ip!, {r0, r1}
200011fa:	f8ac 2000 	strh.w	r2, [ip]
200011fe:	f107 0310 	add.w	r3, r7, #16
20001202:	4618      	mov	r0, r3
20001204:	f04f 01a4 	mov.w	r1, #164	; 0xa4
20001208:	f000 f9b4 	bl	20001574 <HAL_assert_fail>
      
    /* Fill the UART's Tx FIFO until the FIFO is full or the complete input 
     * buffer has been written. */
    if( (this_uart != NULL_INSTANCE) &&
2000120c:	68fb      	ldr	r3, [r7, #12]
2000120e:	2b00      	cmp	r3, #0
20001210:	d037      	beq.n	20001282 <UART_fill_tx_fifo+0x12a>
20001212:	68bb      	ldr	r3, [r7, #8]
20001214:	2b00      	cmp	r3, #0
20001216:	d034      	beq.n	20001282 <UART_fill_tx_fifo+0x12a>
20001218:	687b      	ldr	r3, [r7, #4]
2000121a:	2b00      	cmp	r3, #0
2000121c:	d031      	beq.n	20001282 <UART_fill_tx_fifo+0x12a>
        (tx_buffer != NULL_BUFFER)   &&
        (tx_size > 0u) )
    {
        tx_ready = HAL_get_8bit_reg( this_uart->base_address, STATUS ) &
2000121e:	68fb      	ldr	r3, [r7, #12]
20001220:	681b      	ldr	r3, [r3, #0]
20001222:	f103 0310 	add.w	r3, r3, #16
20001226:	4618      	mov	r0, r3
20001228:	f000 f9ea 	bl	20001600 <HW_get_8bit_reg>
2000122c:	4603      	mov	r3, r0
2000122e:	f003 0301 	and.w	r3, r3, #1
20001232:	f887 3063 	strb.w	r3, [r7, #99]	; 0x63
        		                                      STATUS_TXRDY_MASK;
        if ( tx_ready )
20001236:	f897 3063 	ldrb.w	r3, [r7, #99]	; 0x63
2000123a:	2b00      	cmp	r3, #0
2000123c:	d021      	beq.n	20001282 <UART_fill_tx_fifo+0x12a>
        {
            do {
                HAL_set_8bit_reg( this_uart->base_address, TXDATA,
2000123e:	68fb      	ldr	r3, [r7, #12]
20001240:	681a      	ldr	r2, [r3, #0]
                		          (uint_fast8_t)tx_buffer[size_sent] );
20001242:	68b9      	ldr	r1, [r7, #8]
20001244:	6e7b      	ldr	r3, [r7, #100]	; 0x64
20001246:	440b      	add	r3, r1
20001248:	781b      	ldrb	r3, [r3, #0]
        tx_ready = HAL_get_8bit_reg( this_uart->base_address, STATUS ) &
        		                                      STATUS_TXRDY_MASK;
        if ( tx_ready )
        {
            do {
                HAL_set_8bit_reg( this_uart->base_address, TXDATA,
2000124a:	4610      	mov	r0, r2
2000124c:	4619      	mov	r1, r3
2000124e:	f000 f9d5 	bl	200015fc <HW_set_8bit_reg>
                		          (uint_fast8_t)tx_buffer[size_sent] );
                size_sent++;
20001252:	6e7b      	ldr	r3, [r7, #100]	; 0x64
20001254:	f103 0301 	add.w	r3, r3, #1
20001258:	667b      	str	r3, [r7, #100]	; 0x64
                tx_ready = HAL_get_8bit_reg( this_uart->base_address, STATUS ) &
2000125a:	68fb      	ldr	r3, [r7, #12]
2000125c:	681b      	ldr	r3, [r3, #0]
2000125e:	f103 0310 	add.w	r3, r3, #16
20001262:	4618      	mov	r0, r3
20001264:	f000 f9cc 	bl	20001600 <HW_get_8bit_reg>
20001268:	4603      	mov	r3, r0
2000126a:	f003 0301 	and.w	r3, r3, #1
2000126e:	f887 3063 	strb.w	r3, [r7, #99]	; 0x63
                		                                      STATUS_TXRDY_MASK;
            } while ( (tx_ready) && ( size_sent < tx_size ) );
20001272:	f897 3063 	ldrb.w	r3, [r7, #99]	; 0x63
20001276:	2b00      	cmp	r3, #0
20001278:	d003      	beq.n	20001282 <UART_fill_tx_fifo+0x12a>
2000127a:	6e7a      	ldr	r2, [r7, #100]	; 0x64
2000127c:	687b      	ldr	r3, [r7, #4]
2000127e:	429a      	cmp	r2, r3
20001280:	d3dd      	bcc.n	2000123e <UART_fill_tx_fifo+0xe6>
        }
    }    
    return size_sent;
20001282:	6e7b      	ldr	r3, [r7, #100]	; 0x64
}
20001284:	4618      	mov	r0, r3
20001286:	f107 0768 	add.w	r7, r7, #104	; 0x68
2000128a:	46bd      	mov	sp, r7
2000128c:	bd80      	pop	{r7, pc}
2000128e:	bf00      	nop

20001290 <UART_get_rx>:
(
    UART_instance_t * this_uart,
    uint8_t * rx_buffer,
    size_t buff_size
)
{
20001290:	b590      	push	{r4, r7, lr}
20001292:	b09b      	sub	sp, #108	; 0x6c
20001294:	af00      	add	r7, sp, #0
20001296:	60f8      	str	r0, [r7, #12]
20001298:	60b9      	str	r1, [r7, #8]
2000129a:	607a      	str	r2, [r7, #4]
    uint8_t new_status;
    uint8_t rx_full;
	size_t rx_idx = 0u;
2000129c:	f04f 0300 	mov.w	r3, #0
200012a0:	667b      	str	r3, [r7, #100]	; 0x64
    
	HAL_ASSERT( this_uart != NULL_INSTANCE )
200012a2:	68fb      	ldr	r3, [r7, #12]
200012a4:	2b00      	cmp	r3, #0
200012a6:	d117      	bne.n	200012d8 <UART_get_rx+0x48>
200012a8:	f242 2358 	movw	r3, #8792	; 0x2258
200012ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
200012b0:	f107 0c48 	add.w	ip, r7, #72	; 0x48
200012b4:	469e      	mov	lr, r3
200012b6:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
200012ba:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
200012be:	e89e 0007 	ldmia.w	lr, {r0, r1, r2}
200012c2:	e8ac 0003 	stmia.w	ip!, {r0, r1}
200012c6:	f8ac 2000 	strh.w	r2, [ip]
200012ca:	f107 0348 	add.w	r3, r7, #72	; 0x48
200012ce:	4618      	mov	r0, r3
200012d0:	f04f 01cc 	mov.w	r1, #204	; 0xcc
200012d4:	f000 f94e 	bl	20001574 <HAL_assert_fail>
	HAL_ASSERT( rx_buffer != NULL_BUFFER )
200012d8:	68bb      	ldr	r3, [r7, #8]
200012da:	2b00      	cmp	r3, #0
200012dc:	d117      	bne.n	2000130e <UART_get_rx+0x7e>
200012de:	f242 2358 	movw	r3, #8792	; 0x2258
200012e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200012e6:	f107 0c2c 	add.w	ip, r7, #44	; 0x2c
200012ea:	469e      	mov	lr, r3
200012ec:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
200012f0:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
200012f4:	e89e 0007 	ldmia.w	lr, {r0, r1, r2}
200012f8:	e8ac 0003 	stmia.w	ip!, {r0, r1}
200012fc:	f8ac 2000 	strh.w	r2, [ip]
20001300:	f107 032c 	add.w	r3, r7, #44	; 0x2c
20001304:	4618      	mov	r0, r3
20001306:	f04f 01cd 	mov.w	r1, #205	; 0xcd
2000130a:	f000 f933 	bl	20001574 <HAL_assert_fail>
	HAL_ASSERT( buff_size > 0 )
2000130e:	687b      	ldr	r3, [r7, #4]
20001310:	2b00      	cmp	r3, #0
20001312:	d117      	bne.n	20001344 <UART_get_rx+0xb4>
20001314:	f242 2358 	movw	r3, #8792	; 0x2258
20001318:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000131c:	f107 0c10 	add.w	ip, r7, #16
20001320:	469e      	mov	lr, r3
20001322:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
20001326:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
2000132a:	e89e 0007 	ldmia.w	lr, {r0, r1, r2}
2000132e:	e8ac 0003 	stmia.w	ip!, {r0, r1}
20001332:	f8ac 2000 	strh.w	r2, [ip]
20001336:	f107 0310 	add.w	r3, r7, #16
2000133a:	4618      	mov	r0, r3
2000133c:	f04f 01ce 	mov.w	r1, #206	; 0xce
20001340:	f000 f918 	bl	20001574 <HAL_assert_fail>
      
    if( (this_uart != NULL_INSTANCE) &&
20001344:	68fb      	ldr	r3, [r7, #12]
20001346:	2b00      	cmp	r3, #0
20001348:	d054      	beq.n	200013f4 <UART_get_rx+0x164>
2000134a:	68bb      	ldr	r3, [r7, #8]
2000134c:	2b00      	cmp	r3, #0
2000134e:	d051      	beq.n	200013f4 <UART_get_rx+0x164>
20001350:	687b      	ldr	r3, [r7, #4]
20001352:	2b00      	cmp	r3, #0
20001354:	d04e      	beq.n	200013f4 <UART_get_rx+0x164>
        (rx_buffer != NULL_BUFFER)   &&
        (buff_size > 0u) )
    {
        rx_idx = 0u;
20001356:	f04f 0300 	mov.w	r3, #0
2000135a:	667b      	str	r3, [r7, #100]	; 0x64
        new_status = HAL_get_8bit_reg( this_uart->base_address, STATUS );
2000135c:	68fb      	ldr	r3, [r7, #12]
2000135e:	681b      	ldr	r3, [r3, #0]
20001360:	f103 0310 	add.w	r3, r3, #16
20001364:	4618      	mov	r0, r3
20001366:	f000 f94b 	bl	20001600 <HW_get_8bit_reg>
2000136a:	4603      	mov	r3, r0
2000136c:	f887 3062 	strb.w	r3, [r7, #98]	; 0x62
        this_uart->status |= new_status;
20001370:	68fb      	ldr	r3, [r7, #12]
20001372:	791a      	ldrb	r2, [r3, #4]
20001374:	f897 3062 	ldrb.w	r3, [r7, #98]	; 0x62
20001378:	ea42 0303 	orr.w	r3, r2, r3
2000137c:	b2da      	uxtb	r2, r3
2000137e:	68fb      	ldr	r3, [r7, #12]
20001380:	711a      	strb	r2, [r3, #4]
        rx_full = new_status & STATUS_RXFULL_MASK;
20001382:	f897 3062 	ldrb.w	r3, [r7, #98]	; 0x62
20001386:	f003 0302 	and.w	r3, r3, #2
2000138a:	f887 3063 	strb.w	r3, [r7, #99]	; 0x63
        while ( ( rx_full ) && ( rx_idx < buff_size ) )
2000138e:	e029      	b.n	200013e4 <UART_get_rx+0x154>
        {
            rx_buffer[rx_idx] = HAL_get_8bit_reg( this_uart->base_address,
20001390:	68ba      	ldr	r2, [r7, #8]
20001392:	6e7b      	ldr	r3, [r7, #100]	; 0x64
20001394:	eb02 0403 	add.w	r4, r2, r3
20001398:	68fb      	ldr	r3, [r7, #12]
2000139a:	681b      	ldr	r3, [r3, #0]
2000139c:	f103 0304 	add.w	r3, r3, #4
200013a0:	4618      	mov	r0, r3
200013a2:	f000 f92d 	bl	20001600 <HW_get_8bit_reg>
200013a6:	4603      	mov	r3, r0
200013a8:	7023      	strb	r3, [r4, #0]
            		                              RXDATA );
            rx_idx++;
200013aa:	6e7b      	ldr	r3, [r7, #100]	; 0x64
200013ac:	f103 0301 	add.w	r3, r3, #1
200013b0:	667b      	str	r3, [r7, #100]	; 0x64
            new_status = HAL_get_8bit_reg( this_uart->base_address, STATUS );
200013b2:	68fb      	ldr	r3, [r7, #12]
200013b4:	681b      	ldr	r3, [r3, #0]
200013b6:	f103 0310 	add.w	r3, r3, #16
200013ba:	4618      	mov	r0, r3
200013bc:	f000 f920 	bl	20001600 <HW_get_8bit_reg>
200013c0:	4603      	mov	r3, r0
200013c2:	f887 3062 	strb.w	r3, [r7, #98]	; 0x62
            this_uart->status |= new_status;
200013c6:	68fb      	ldr	r3, [r7, #12]
200013c8:	791a      	ldrb	r2, [r3, #4]
200013ca:	f897 3062 	ldrb.w	r3, [r7, #98]	; 0x62
200013ce:	ea42 0303 	orr.w	r3, r2, r3
200013d2:	b2da      	uxtb	r2, r3
200013d4:	68fb      	ldr	r3, [r7, #12]
200013d6:	711a      	strb	r2, [r3, #4]
            rx_full = new_status & STATUS_RXFULL_MASK;
200013d8:	f897 3062 	ldrb.w	r3, [r7, #98]	; 0x62
200013dc:	f003 0302 	and.w	r3, r3, #2
200013e0:	f887 3063 	strb.w	r3, [r7, #99]	; 0x63
    {
        rx_idx = 0u;
        new_status = HAL_get_8bit_reg( this_uart->base_address, STATUS );
        this_uart->status |= new_status;
        rx_full = new_status & STATUS_RXFULL_MASK;
        while ( ( rx_full ) && ( rx_idx < buff_size ) )
200013e4:	f897 3063 	ldrb.w	r3, [r7, #99]	; 0x63
200013e8:	2b00      	cmp	r3, #0
200013ea:	d003      	beq.n	200013f4 <UART_get_rx+0x164>
200013ec:	6e7a      	ldr	r2, [r7, #100]	; 0x64
200013ee:	687b      	ldr	r3, [r7, #4]
200013f0:	429a      	cmp	r2, r3
200013f2:	d3cd      	bcc.n	20001390 <UART_get_rx+0x100>
            new_status = HAL_get_8bit_reg( this_uart->base_address, STATUS );
            this_uart->status |= new_status;
            rx_full = new_status & STATUS_RXFULL_MASK;
        }
    }
    return rx_idx;
200013f4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
}
200013f6:	4618      	mov	r0, r3
200013f8:	f107 076c 	add.w	r7, r7, #108	; 0x6c
200013fc:	46bd      	mov	sp, r7
200013fe:	bd90      	pop	{r4, r7, pc}

20001400 <UART_polled_tx_string>:
UART_polled_tx_string
( 
	UART_instance_t * this_uart, 
	const uint8_t * p_sz_string
)
{
20001400:	b580      	push	{r7, lr}
20001402:	b092      	sub	sp, #72	; 0x48
20001404:	af00      	add	r7, sp, #0
20001406:	6078      	str	r0, [r7, #4]
20001408:	6039      	str	r1, [r7, #0]
	uint32_t char_idx;
    uint8_t tx_ready;

    HAL_ASSERT( this_uart != NULL_INSTANCE )
2000140a:	687b      	ldr	r3, [r7, #4]
2000140c:	2b00      	cmp	r3, #0
2000140e:	d117      	bne.n	20001440 <UART_polled_tx_string+0x40>
20001410:	f242 2358 	movw	r3, #8792	; 0x2258
20001414:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001418:	f107 0c24 	add.w	ip, r7, #36	; 0x24
2000141c:	469e      	mov	lr, r3
2000141e:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
20001422:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
20001426:	e89e 0007 	ldmia.w	lr, {r0, r1, r2}
2000142a:	e8ac 0003 	stmia.w	ip!, {r0, r1}
2000142e:	f8ac 2000 	strh.w	r2, [ip]
20001432:	f107 0324 	add.w	r3, r7, #36	; 0x24
20001436:	4618      	mov	r0, r3
20001438:	f04f 01f3 	mov.w	r1, #243	; 0xf3
2000143c:	f000 f89a 	bl	20001574 <HAL_assert_fail>
	HAL_ASSERT( p_sz_string != NULL_BUFFER )
20001440:	683b      	ldr	r3, [r7, #0]
20001442:	2b00      	cmp	r3, #0
20001444:	d117      	bne.n	20001476 <UART_polled_tx_string+0x76>
20001446:	f242 2358 	movw	r3, #8792	; 0x2258
2000144a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000144e:	f107 0c08 	add.w	ip, r7, #8
20001452:	469e      	mov	lr, r3
20001454:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
20001458:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
2000145c:	e89e 0007 	ldmia.w	lr, {r0, r1, r2}
20001460:	e8ac 0003 	stmia.w	ip!, {r0, r1}
20001464:	f8ac 2000 	strh.w	r2, [ip]
20001468:	f107 0308 	add.w	r3, r7, #8
2000146c:	4618      	mov	r0, r3
2000146e:	f04f 01f4 	mov.w	r1, #244	; 0xf4
20001472:	f000 f87f 	bl	20001574 <HAL_assert_fail>
    
    if( ( this_uart != NULL_INSTANCE ) && ( p_sz_string != NULL_BUFFER ) )
20001476:	687b      	ldr	r3, [r7, #4]
20001478:	2b00      	cmp	r3, #0
2000147a:	d02a      	beq.n	200014d2 <UART_polled_tx_string+0xd2>
2000147c:	683b      	ldr	r3, [r7, #0]
2000147e:	2b00      	cmp	r3, #0
20001480:	d027      	beq.n	200014d2 <UART_polled_tx_string+0xd2>
    {
        char_idx = 0U;
20001482:	f04f 0300 	mov.w	r3, #0
20001486:	643b      	str	r3, [r7, #64]	; 0x40
        while( 0U != p_sz_string[char_idx] )
20001488:	e01d      	b.n	200014c6 <UART_polled_tx_string+0xc6>
        {
            /* Wait for UART to become ready to transmit. */
            do {
                tx_ready = HAL_get_8bit_reg( this_uart->base_address, STATUS ) &
2000148a:	687b      	ldr	r3, [r7, #4]
2000148c:	681b      	ldr	r3, [r3, #0]
2000148e:	f103 0310 	add.w	r3, r3, #16
20001492:	4618      	mov	r0, r3
20001494:	f000 f8b4 	bl	20001600 <HW_get_8bit_reg>
20001498:	4603      	mov	r3, r0
2000149a:	f003 0301 	and.w	r3, r3, #1
2000149e:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
                		                                      STATUS_TXRDY_MASK;
            } while ( !tx_ready );
200014a2:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
200014a6:	2b00      	cmp	r3, #0
200014a8:	d0ef      	beq.n	2000148a <UART_polled_tx_string+0x8a>
            /* Send next character in the buffer. */
            HAL_set_8bit_reg( this_uart->base_address, TXDATA,
200014aa:	687b      	ldr	r3, [r7, #4]
200014ac:	681a      	ldr	r2, [r3, #0]
            		          (uint_fast8_t)p_sz_string[char_idx] );
200014ae:	6839      	ldr	r1, [r7, #0]
200014b0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
200014b2:	440b      	add	r3, r1
200014b4:	781b      	ldrb	r3, [r3, #0]
            do {
                tx_ready = HAL_get_8bit_reg( this_uart->base_address, STATUS ) &
                		                                      STATUS_TXRDY_MASK;
            } while ( !tx_ready );
            /* Send next character in the buffer. */
            HAL_set_8bit_reg( this_uart->base_address, TXDATA,
200014b6:	4610      	mov	r0, r2
200014b8:	4619      	mov	r1, r3
200014ba:	f000 f89f 	bl	200015fc <HW_set_8bit_reg>
            		          (uint_fast8_t)p_sz_string[char_idx] );
            char_idx++;
200014be:	6c3b      	ldr	r3, [r7, #64]	; 0x40
200014c0:	f103 0301 	add.w	r3, r3, #1
200014c4:	643b      	str	r3, [r7, #64]	; 0x40
	HAL_ASSERT( p_sz_string != NULL_BUFFER )
    
    if( ( this_uart != NULL_INSTANCE ) && ( p_sz_string != NULL_BUFFER ) )
    {
        char_idx = 0U;
        while( 0U != p_sz_string[char_idx] )
200014c6:	683a      	ldr	r2, [r7, #0]
200014c8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
200014ca:	4413      	add	r3, r2
200014cc:	781b      	ldrb	r3, [r3, #0]
200014ce:	2b00      	cmp	r3, #0
200014d0:	d1db      	bne.n	2000148a <UART_polled_tx_string+0x8a>
            HAL_set_8bit_reg( this_uart->base_address, TXDATA,
            		          (uint_fast8_t)p_sz_string[char_idx] );
            char_idx++;
        }
    }
}
200014d2:	f107 0748 	add.w	r7, r7, #72	; 0x48
200014d6:	46bd      	mov	sp, r7
200014d8:	bd80      	pop	{r7, pc}
200014da:	bf00      	nop

200014dc <UART_get_rx_status>:
uint8_t
UART_get_rx_status
(
    UART_instance_t * this_uart
)
{
200014dc:	b580      	push	{r7, lr}
200014de:	b08a      	sub	sp, #40	; 0x28
200014e0:	af00      	add	r7, sp, #0
200014e2:	6078      	str	r0, [r7, #4]
	uint8_t status = UART_APB_INVALID_PARAM;
200014e4:	f04f 33ff 	mov.w	r3, #4294967295
200014e8:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

    HAL_ASSERT( this_uart != NULL_INSTANCE )
200014ec:	687b      	ldr	r3, [r7, #4]
200014ee:	2b00      	cmp	r3, #0
200014f0:	d117      	bne.n	20001522 <UART_get_rx_status+0x46>
200014f2:	f242 2358 	movw	r3, #8792	; 0x2258
200014f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200014fa:	f107 0c0c 	add.w	ip, r7, #12
200014fe:	469e      	mov	lr, r3
20001500:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
20001504:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
20001508:	e89e 0007 	ldmia.w	lr, {r0, r1, r2}
2000150c:	e8ac 0003 	stmia.w	ip!, {r0, r1}
20001510:	f8ac 2000 	strh.w	r2, [ip]
20001514:	f107 030c 	add.w	r3, r7, #12
20001518:	4618      	mov	r0, r3
2000151a:	f44f 718a 	mov.w	r1, #276	; 0x114
2000151e:	f000 f829 	bl	20001574 <HAL_assert_fail>
     * Extract UART error status and place in lower bits of "status".
     * Bit 0 - Parity error status
     * Bit 1 - Overflow error status
     * Bit 2 - Frame error status
     */
    if( this_uart != NULL_INSTANCE )
20001522:	687b      	ldr	r3, [r7, #4]
20001524:	2b00      	cmp	r3, #0
20001526:	d00b      	beq.n	20001540 <UART_get_rx_status+0x64>
    {
        status = ( ( this_uart->status & STATUS_ERROR_MASK ) >> 
20001528:	687b      	ldr	r3, [r7, #4]
2000152a:	791b      	ldrb	r3, [r3, #4]
2000152c:	f003 031c 	and.w	r3, r3, #28
20001530:	ea4f 03a3 	mov.w	r3, r3, asr #2
20001534:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
                                          STATUS_ERROR_OFFSET );
        /*
         * Clear the sticky status for this instance.
         */
        this_uart->status = (uint8_t)0;
20001538:	687b      	ldr	r3, [r7, #4]
2000153a:	f04f 0200 	mov.w	r2, #0
2000153e:	711a      	strb	r2, [r3, #4]
    }
    return status;
20001540:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
}
20001544:	4618      	mov	r0, r3
20001546:	f107 0728 	add.w	r7, r7, #40	; 0x28
2000154a:	46bd      	mov	sp, r7
2000154c:	bd80      	pop	{r7, pc}
2000154e:	bf00      	nop

20001550 <barcode_init>:
#include "device/barcode.h"
#include "driver/core_uart_apb.h"
#include <stdio.h>
#include <stdarg.h>

void barcode_init() {
20001550:	b580      	push	{r7, lr}
20001552:	af00      	add	r7, sp, #0
	/* Initialize CoreUARTapb for bar code scanner settings */
	UART_init(&g_barcode_uart, BARCODE_UART_BASE_ADDR, BARCODE_BAUD_VALUE, DATA_8_BITS | NO_PARITY);
20001554:	f642 0004 	movw	r0, #10244	; 0x2804
20001558:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000155c:	f240 2100 	movw	r1, #512	; 0x200
20001560:	f2c4 0105 	movt	r1, #16389	; 0x4005
20001564:	f240 228a 	movw	r2, #650	; 0x28a
20001568:	f04f 0301 	mov.w	r3, #1
2000156c:	f7ff fc52 	bl	20000e14 <UART_init>
}
20001570:	bd80      	pop	{r7, pc}
20001572:	bf00      	nop

20001574 <HAL_assert_fail>:
void HAL_assert_fail
(
    const uint8_t * file_name,
    uint32_t line_no
)
{
20001574:	b480      	push	{r7}
20001576:	b087      	sub	sp, #28
20001578:	af00      	add	r7, sp, #0
2000157a:	6078      	str	r0, [r7, #4]
2000157c:	6039      	str	r1, [r7, #0]
    while(1)
    {
        volatile const uint8_t * assert_file = file_name;
2000157e:	687b      	ldr	r3, [r7, #4]
20001580:	617b      	str	r3, [r7, #20]
        volatile uint32_t assert_line = line_no;
20001582:	683b      	ldr	r3, [r7, #0]
20001584:	613b      	str	r3, [r7, #16]
        volatile char dummy;
		volatile uint32_t i_dummy;
		
		/* following lines to avoid compiler warnings: */
        dummy = *assert_file;
20001586:	697b      	ldr	r3, [r7, #20]
20001588:	781b      	ldrb	r3, [r3, #0]
2000158a:	b2db      	uxtb	r3, r3
2000158c:	73fb      	strb	r3, [r7, #15]
		i_dummy = assert_line;
2000158e:	693b      	ldr	r3, [r7, #16]
20001590:	60bb      	str	r3, [r7, #8]
		i_dummy++;
20001592:	68bb      	ldr	r3, [r7, #8]
20001594:	f103 0301 	add.w	r3, r3, #1
20001598:	60bb      	str	r3, [r7, #8]
    }
2000159a:	e7f0      	b.n	2000157e <HAL_assert_fail+0xa>

2000159c <HW_set_32bit_reg>:
2000159c:	6001      	str	r1, [r0, #0]
2000159e:	4770      	bx	lr

200015a0 <HW_get_32bit_reg>:
200015a0:	6800      	ldr	r0, [r0, #0]
200015a2:	4770      	bx	lr

200015a4 <HW_set_32bit_reg_field>:
200015a4:	b50e      	push	{r1, r2, r3, lr}
200015a6:	fa03 f301 	lsl.w	r3, r3, r1
200015aa:	ea03 0302 	and.w	r3, r3, r2
200015ae:	6801      	ldr	r1, [r0, #0]
200015b0:	ea6f 0202 	mvn.w	r2, r2
200015b4:	ea01 0102 	and.w	r1, r1, r2
200015b8:	ea41 0103 	orr.w	r1, r1, r3
200015bc:	6001      	str	r1, [r0, #0]
200015be:	bd0e      	pop	{r1, r2, r3, pc}

200015c0 <HW_get_32bit_reg_field>:
200015c0:	6800      	ldr	r0, [r0, #0]
200015c2:	ea00 0002 	and.w	r0, r0, r2
200015c6:	fa20 f001 	lsr.w	r0, r0, r1
200015ca:	4770      	bx	lr

200015cc <HW_set_16bit_reg>:
200015cc:	8001      	strh	r1, [r0, #0]
200015ce:	4770      	bx	lr

200015d0 <HW_get_16bit_reg>:
200015d0:	8800      	ldrh	r0, [r0, #0]
200015d2:	4770      	bx	lr

200015d4 <HW_set_16bit_reg_field>:
200015d4:	b50e      	push	{r1, r2, r3, lr}
200015d6:	fa03 f301 	lsl.w	r3, r3, r1
200015da:	ea03 0302 	and.w	r3, r3, r2
200015de:	8801      	ldrh	r1, [r0, #0]
200015e0:	ea6f 0202 	mvn.w	r2, r2
200015e4:	ea01 0102 	and.w	r1, r1, r2
200015e8:	ea41 0103 	orr.w	r1, r1, r3
200015ec:	8001      	strh	r1, [r0, #0]
200015ee:	bd0e      	pop	{r1, r2, r3, pc}

200015f0 <HW_get_16bit_reg_field>:
200015f0:	8800      	ldrh	r0, [r0, #0]
200015f2:	ea00 0002 	and.w	r0, r0, r2
200015f6:	fa20 f001 	lsr.w	r0, r0, r1
200015fa:	4770      	bx	lr

200015fc <HW_set_8bit_reg>:
200015fc:	7001      	strb	r1, [r0, #0]
200015fe:	4770      	bx	lr

20001600 <HW_get_8bit_reg>:
20001600:	7800      	ldrb	r0, [r0, #0]
20001602:	4770      	bx	lr

20001604 <HW_set_8bit_reg_field>:
20001604:	b50e      	push	{r1, r2, r3, lr}
20001606:	fa03 f301 	lsl.w	r3, r3, r1
2000160a:	ea03 0302 	and.w	r3, r3, r2
2000160e:	7801      	ldrb	r1, [r0, #0]
20001610:	ea6f 0202 	mvn.w	r2, r2
20001614:	ea01 0102 	and.w	r1, r1, r2
20001618:	ea41 0103 	orr.w	r1, r1, r3
2000161c:	7001      	strb	r1, [r0, #0]
2000161e:	bd0e      	pop	{r1, r2, r3, pc}

20001620 <HW_get_8bit_reg_field>:
20001620:	7800      	ldrb	r0, [r0, #0]
20001622:	ea00 0002 	and.w	r0, r0, r2
20001626:	fa20 f001 	lsr.w	r0, r0, r1
2000162a:	4770      	bx	lr

2000162c <abort>:
2000162c:	b508      	push	{r3, lr}
2000162e:	2006      	movs	r0, #6
20001630:	f000 f8de 	bl	200017f0 <raise>
20001634:	2001      	movs	r0, #1
20001636:	f7fe fff7 	bl	20000628 <_exit>
2000163a:	bf00      	nop

2000163c <__libc_init_array>:
2000163c:	b570      	push	{r4, r5, r6, lr}
2000163e:	f242 2694 	movw	r6, #8852	; 0x2294
20001642:	f242 2594 	movw	r5, #8852	; 0x2294
20001646:	f2c2 0600 	movt	r6, #8192	; 0x2000
2000164a:	f2c2 0500 	movt	r5, #8192	; 0x2000
2000164e:	1b76      	subs	r6, r6, r5
20001650:	10b6      	asrs	r6, r6, #2
20001652:	d006      	beq.n	20001662 <__libc_init_array+0x26>
20001654:	2400      	movs	r4, #0
20001656:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
2000165a:	3401      	adds	r4, #1
2000165c:	4798      	blx	r3
2000165e:	42a6      	cmp	r6, r4
20001660:	d8f9      	bhi.n	20001656 <__libc_init_array+0x1a>
20001662:	f242 2594 	movw	r5, #8852	; 0x2294
20001666:	f242 2698 	movw	r6, #8856	; 0x2298
2000166a:	f2c2 0500 	movt	r5, #8192	; 0x2000
2000166e:	f2c2 0600 	movt	r6, #8192	; 0x2000
20001672:	1b76      	subs	r6, r6, r5
20001674:	f000 fe02 	bl	2000227c <_init>
20001678:	10b6      	asrs	r6, r6, #2
2000167a:	d006      	beq.n	2000168a <__libc_init_array+0x4e>
2000167c:	2400      	movs	r4, #0
2000167e:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
20001682:	3401      	adds	r4, #1
20001684:	4798      	blx	r3
20001686:	42a6      	cmp	r6, r4
20001688:	d8f9      	bhi.n	2000167e <__libc_init_array+0x42>
2000168a:	bd70      	pop	{r4, r5, r6, pc}

2000168c <_wrapup_reent>:
2000168c:	b570      	push	{r4, r5, r6, lr}
2000168e:	4604      	mov	r4, r0
20001690:	b188      	cbz	r0, 200016b6 <_wrapup_reent+0x2a>
20001692:	f104 0248 	add.w	r2, r4, #72	; 0x48
20001696:	6853      	ldr	r3, [r2, #4]
20001698:	1e5d      	subs	r5, r3, #1
2000169a:	d407      	bmi.n	200016ac <_wrapup_reent+0x20>
2000169c:	3302      	adds	r3, #2
2000169e:	eb02 0683 	add.w	r6, r2, r3, lsl #2
200016a2:	f856 3d04 	ldr.w	r3, [r6, #-4]!
200016a6:	4798      	blx	r3
200016a8:	3d01      	subs	r5, #1
200016aa:	d5fa      	bpl.n	200016a2 <_wrapup_reent+0x16>
200016ac:	6aa3      	ldr	r3, [r4, #40]	; 0x28
200016ae:	b10b      	cbz	r3, 200016b4 <_wrapup_reent+0x28>
200016b0:	4620      	mov	r0, r4
200016b2:	4798      	blx	r3
200016b4:	bd70      	pop	{r4, r5, r6, pc}
200016b6:	f242 23c0 	movw	r3, #8896	; 0x22c0
200016ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
200016be:	681c      	ldr	r4, [r3, #0]
200016c0:	e7e7      	b.n	20001692 <_wrapup_reent+0x6>
200016c2:	bf00      	nop

200016c4 <cleanup_glue>:
200016c4:	b570      	push	{r4, r5, r6, lr}
200016c6:	460c      	mov	r4, r1
200016c8:	6809      	ldr	r1, [r1, #0]
200016ca:	4605      	mov	r5, r0
200016cc:	b109      	cbz	r1, 200016d2 <cleanup_glue+0xe>
200016ce:	f7ff fff9 	bl	200016c4 <cleanup_glue>
200016d2:	4628      	mov	r0, r5
200016d4:	4621      	mov	r1, r4
200016d6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
200016da:	f000 b97d 	b.w	200019d8 <_free_r>
200016de:	bf00      	nop

200016e0 <_reclaim_reent>:
200016e0:	f242 23c0 	movw	r3, #8896	; 0x22c0
200016e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200016e8:	b570      	push	{r4, r5, r6, lr}
200016ea:	681b      	ldr	r3, [r3, #0]
200016ec:	4605      	mov	r5, r0
200016ee:	4298      	cmp	r0, r3
200016f0:	d046      	beq.n	20001780 <_reclaim_reent+0xa0>
200016f2:	6a43      	ldr	r3, [r0, #36]	; 0x24
200016f4:	4619      	mov	r1, r3
200016f6:	b1bb      	cbz	r3, 20001728 <_reclaim_reent+0x48>
200016f8:	68da      	ldr	r2, [r3, #12]
200016fa:	b1aa      	cbz	r2, 20001728 <_reclaim_reent+0x48>
200016fc:	2600      	movs	r6, #0
200016fe:	5991      	ldr	r1, [r2, r6]
20001700:	b141      	cbz	r1, 20001714 <_reclaim_reent+0x34>
20001702:	680c      	ldr	r4, [r1, #0]
20001704:	4628      	mov	r0, r5
20001706:	f000 f967 	bl	200019d8 <_free_r>
2000170a:	4621      	mov	r1, r4
2000170c:	2c00      	cmp	r4, #0
2000170e:	d1f8      	bne.n	20001702 <_reclaim_reent+0x22>
20001710:	6a6b      	ldr	r3, [r5, #36]	; 0x24
20001712:	68da      	ldr	r2, [r3, #12]
20001714:	3604      	adds	r6, #4
20001716:	2e3c      	cmp	r6, #60	; 0x3c
20001718:	d001      	beq.n	2000171e <_reclaim_reent+0x3e>
2000171a:	68da      	ldr	r2, [r3, #12]
2000171c:	e7ef      	b.n	200016fe <_reclaim_reent+0x1e>
2000171e:	4611      	mov	r1, r2
20001720:	4628      	mov	r0, r5
20001722:	f000 f959 	bl	200019d8 <_free_r>
20001726:	6a69      	ldr	r1, [r5, #36]	; 0x24
20001728:	6809      	ldr	r1, [r1, #0]
2000172a:	b111      	cbz	r1, 20001732 <_reclaim_reent+0x52>
2000172c:	4628      	mov	r0, r5
2000172e:	f000 f953 	bl	200019d8 <_free_r>
20001732:	6969      	ldr	r1, [r5, #20]
20001734:	b111      	cbz	r1, 2000173c <_reclaim_reent+0x5c>
20001736:	4628      	mov	r0, r5
20001738:	f000 f94e 	bl	200019d8 <_free_r>
2000173c:	6a69      	ldr	r1, [r5, #36]	; 0x24
2000173e:	b111      	cbz	r1, 20001746 <_reclaim_reent+0x66>
20001740:	4628      	mov	r0, r5
20001742:	f000 f949 	bl	200019d8 <_free_r>
20001746:	6ba9      	ldr	r1, [r5, #56]	; 0x38
20001748:	b111      	cbz	r1, 20001750 <_reclaim_reent+0x70>
2000174a:	4628      	mov	r0, r5
2000174c:	f000 f944 	bl	200019d8 <_free_r>
20001750:	6be9      	ldr	r1, [r5, #60]	; 0x3c
20001752:	b111      	cbz	r1, 2000175a <_reclaim_reent+0x7a>
20001754:	4628      	mov	r0, r5
20001756:	f000 f93f 	bl	200019d8 <_free_r>
2000175a:	6c29      	ldr	r1, [r5, #64]	; 0x40
2000175c:	b111      	cbz	r1, 20001764 <_reclaim_reent+0x84>
2000175e:	4628      	mov	r0, r5
20001760:	f000 f93a 	bl	200019d8 <_free_r>
20001764:	6cab      	ldr	r3, [r5, #72]	; 0x48
20001766:	f8d3 1088 	ldr.w	r1, [r3, #136]	; 0x88
2000176a:	b111      	cbz	r1, 20001772 <_reclaim_reent+0x92>
2000176c:	4628      	mov	r0, r5
2000176e:	f000 f933 	bl	200019d8 <_free_r>
20001772:	6b69      	ldr	r1, [r5, #52]	; 0x34
20001774:	b111      	cbz	r1, 2000177c <_reclaim_reent+0x9c>
20001776:	4628      	mov	r0, r5
20001778:	f000 f92e 	bl	200019d8 <_free_r>
2000177c:	69ab      	ldr	r3, [r5, #24]
2000177e:	b903      	cbnz	r3, 20001782 <_reclaim_reent+0xa2>
20001780:	bd70      	pop	{r4, r5, r6, pc}
20001782:	6aab      	ldr	r3, [r5, #40]	; 0x28
20001784:	4628      	mov	r0, r5
20001786:	4798      	blx	r3
20001788:	f8d5 10d8 	ldr.w	r1, [r5, #216]	; 0xd8
2000178c:	2900      	cmp	r1, #0
2000178e:	d0f7      	beq.n	20001780 <_reclaim_reent+0xa0>
20001790:	4628      	mov	r0, r5
20001792:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
20001796:	e795      	b.n	200016c4 <cleanup_glue>

20001798 <_raise_r>:
20001798:	291f      	cmp	r1, #31
2000179a:	b570      	push	{r4, r5, r6, lr}
2000179c:	460c      	mov	r4, r1
2000179e:	4605      	mov	r5, r0
200017a0:	d820      	bhi.n	200017e4 <_raise_r+0x4c>
200017a2:	6c42      	ldr	r2, [r0, #68]	; 0x44
200017a4:	b1a2      	cbz	r2, 200017d0 <_raise_r+0x38>
200017a6:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
200017aa:	b18b      	cbz	r3, 200017d0 <_raise_r+0x38>
200017ac:	2b01      	cmp	r3, #1
200017ae:	d00d      	beq.n	200017cc <_raise_r+0x34>
200017b0:	f1b3 3fff 	cmp.w	r3, #4294967295
200017b4:	d006      	beq.n	200017c4 <_raise_r+0x2c>
200017b6:	4608      	mov	r0, r1
200017b8:	2500      	movs	r5, #0
200017ba:	f842 5021 	str.w	r5, [r2, r1, lsl #2]
200017be:	4798      	blx	r3
200017c0:	4628      	mov	r0, r5
200017c2:	bd70      	pop	{r4, r5, r6, pc}
200017c4:	2316      	movs	r3, #22
200017c6:	6003      	str	r3, [r0, #0]
200017c8:	2001      	movs	r0, #1
200017ca:	bd70      	pop	{r4, r5, r6, pc}
200017cc:	2000      	movs	r0, #0
200017ce:	bd70      	pop	{r4, r5, r6, pc}
200017d0:	4628      	mov	r0, r5
200017d2:	f000 f887 	bl	200018e4 <_getpid_r>
200017d6:	4622      	mov	r2, r4
200017d8:	4601      	mov	r1, r0
200017da:	4628      	mov	r0, r5
200017dc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
200017e0:	f000 b882 	b.w	200018e8 <_kill_r>
200017e4:	2316      	movs	r3, #22
200017e6:	6003      	str	r3, [r0, #0]
200017e8:	f04f 30ff 	mov.w	r0, #4294967295
200017ec:	bd70      	pop	{r4, r5, r6, pc}
200017ee:	bf00      	nop

200017f0 <raise>:
200017f0:	f242 23c0 	movw	r3, #8896	; 0x22c0
200017f4:	4601      	mov	r1, r0
200017f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200017fa:	6818      	ldr	r0, [r3, #0]
200017fc:	e7cc      	b.n	20001798 <_raise_r>
200017fe:	bf00      	nop

20001800 <_init_signal_r>:
20001800:	b538      	push	{r3, r4, r5, lr}
20001802:	6c45      	ldr	r5, [r0, #68]	; 0x44
20001804:	4604      	mov	r4, r0
20001806:	b10d      	cbz	r5, 2000180c <_init_signal_r+0xc>
20001808:	2000      	movs	r0, #0
2000180a:	bd38      	pop	{r3, r4, r5, pc}
2000180c:	2180      	movs	r1, #128	; 0x80
2000180e:	f000 f9c3 	bl	20001b98 <_malloc_r>
20001812:	6460      	str	r0, [r4, #68]	; 0x44
20001814:	b128      	cbz	r0, 20001822 <_init_signal_r+0x22>
20001816:	462b      	mov	r3, r5
20001818:	5143      	str	r3, [r0, r5]
2000181a:	3504      	adds	r5, #4
2000181c:	2d80      	cmp	r5, #128	; 0x80
2000181e:	d1fb      	bne.n	20001818 <_init_signal_r+0x18>
20001820:	e7f2      	b.n	20001808 <_init_signal_r+0x8>
20001822:	3801      	subs	r0, #1
20001824:	bd38      	pop	{r3, r4, r5, pc}
20001826:	bf00      	nop

20001828 <_init_signal>:
20001828:	f242 23c0 	movw	r3, #8896	; 0x22c0
2000182c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001830:	6818      	ldr	r0, [r3, #0]
20001832:	e7e5      	b.n	20001800 <_init_signal_r>

20001834 <__sigtramp_r>:
20001834:	291f      	cmp	r1, #31
20001836:	b510      	push	{r4, lr}
20001838:	4604      	mov	r4, r0
2000183a:	b082      	sub	sp, #8
2000183c:	d812      	bhi.n	20001864 <__sigtramp_r+0x30>
2000183e:	6c42      	ldr	r2, [r0, #68]	; 0x44
20001840:	b1ca      	cbz	r2, 20001876 <__sigtramp_r+0x42>
20001842:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
20001846:	eb02 0281 	add.w	r2, r2, r1, lsl #2
2000184a:	b183      	cbz	r3, 2000186e <__sigtramp_r+0x3a>
2000184c:	f1b3 3fff 	cmp.w	r3, #4294967295
20001850:	d00f      	beq.n	20001872 <__sigtramp_r+0x3e>
20001852:	2b01      	cmp	r3, #1
20001854:	d009      	beq.n	2000186a <__sigtramp_r+0x36>
20001856:	4608      	mov	r0, r1
20001858:	2400      	movs	r4, #0
2000185a:	6014      	str	r4, [r2, #0]
2000185c:	4798      	blx	r3
2000185e:	4620      	mov	r0, r4
20001860:	b002      	add	sp, #8
20001862:	bd10      	pop	{r4, pc}
20001864:	f04f 30ff 	mov.w	r0, #4294967295
20001868:	e7fa      	b.n	20001860 <__sigtramp_r+0x2c>
2000186a:	2003      	movs	r0, #3
2000186c:	e7f8      	b.n	20001860 <__sigtramp_r+0x2c>
2000186e:	2001      	movs	r0, #1
20001870:	e7f6      	b.n	20001860 <__sigtramp_r+0x2c>
20001872:	2002      	movs	r0, #2
20001874:	e7f4      	b.n	20001860 <__sigtramp_r+0x2c>
20001876:	9101      	str	r1, [sp, #4]
20001878:	f7ff ffc2 	bl	20001800 <_init_signal_r>
2000187c:	9901      	ldr	r1, [sp, #4]
2000187e:	2800      	cmp	r0, #0
20001880:	d1f0      	bne.n	20001864 <__sigtramp_r+0x30>
20001882:	6c62      	ldr	r2, [r4, #68]	; 0x44
20001884:	e7dd      	b.n	20001842 <__sigtramp_r+0xe>
20001886:	bf00      	nop

20001888 <__sigtramp>:
20001888:	f242 23c0 	movw	r3, #8896	; 0x22c0
2000188c:	4601      	mov	r1, r0
2000188e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001892:	6818      	ldr	r0, [r3, #0]
20001894:	e7ce      	b.n	20001834 <__sigtramp_r>
20001896:	bf00      	nop

20001898 <_signal_r>:
20001898:	291f      	cmp	r1, #31
2000189a:	b510      	push	{r4, lr}
2000189c:	4604      	mov	r4, r0
2000189e:	b082      	sub	sp, #8
200018a0:	d807      	bhi.n	200018b2 <_signal_r+0x1a>
200018a2:	6c43      	ldr	r3, [r0, #68]	; 0x44
200018a4:	b153      	cbz	r3, 200018bc <_signal_r+0x24>
200018a6:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
200018aa:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
200018ae:	b002      	add	sp, #8
200018b0:	bd10      	pop	{r4, pc}
200018b2:	2316      	movs	r3, #22
200018b4:	6003      	str	r3, [r0, #0]
200018b6:	f04f 30ff 	mov.w	r0, #4294967295
200018ba:	e7f8      	b.n	200018ae <_signal_r+0x16>
200018bc:	9101      	str	r1, [sp, #4]
200018be:	9200      	str	r2, [sp, #0]
200018c0:	f7ff ff9e 	bl	20001800 <_init_signal_r>
200018c4:	9901      	ldr	r1, [sp, #4]
200018c6:	9a00      	ldr	r2, [sp, #0]
200018c8:	b908      	cbnz	r0, 200018ce <_signal_r+0x36>
200018ca:	6c63      	ldr	r3, [r4, #68]	; 0x44
200018cc:	e7eb      	b.n	200018a6 <_signal_r+0xe>
200018ce:	f04f 30ff 	mov.w	r0, #4294967295
200018d2:	e7ec      	b.n	200018ae <_signal_r+0x16>

200018d4 <signal>:
200018d4:	f242 23c0 	movw	r3, #8896	; 0x22c0
200018d8:	460a      	mov	r2, r1
200018da:	f2c2 0300 	movt	r3, #8192	; 0x2000
200018de:	4601      	mov	r1, r0
200018e0:	6818      	ldr	r0, [r3, #0]
200018e2:	e7d9      	b.n	20001898 <_signal_r>

200018e4 <_getpid_r>:
200018e4:	f7fe bec8 	b.w	20000678 <_getpid>

200018e8 <_kill_r>:
200018e8:	b538      	push	{r3, r4, r5, lr}
200018ea:	f642 042c 	movw	r4, #10284	; 0x282c
200018ee:	f2c2 0400 	movt	r4, #8192	; 0x2000
200018f2:	4605      	mov	r5, r0
200018f4:	4608      	mov	r0, r1
200018f6:	4611      	mov	r1, r2
200018f8:	2300      	movs	r3, #0
200018fa:	6023      	str	r3, [r4, #0]
200018fc:	f7fe fed0 	bl	200006a0 <_kill>
20001900:	f1b0 3fff 	cmp.w	r0, #4294967295
20001904:	d000      	beq.n	20001908 <_kill_r+0x20>
20001906:	bd38      	pop	{r3, r4, r5, pc}
20001908:	6823      	ldr	r3, [r4, #0]
2000190a:	2b00      	cmp	r3, #0
2000190c:	d0fb      	beq.n	20001906 <_kill_r+0x1e>
2000190e:	602b      	str	r3, [r5, #0]
20001910:	bd38      	pop	{r3, r4, r5, pc}
20001912:	bf00      	nop

20001914 <write>:
20001914:	b410      	push	{r4}
20001916:	f242 24c0 	movw	r4, #8896	; 0x22c0
2000191a:	f2c2 0400 	movt	r4, #8192	; 0x2000
2000191e:	468c      	mov	ip, r1
20001920:	4613      	mov	r3, r2
20001922:	4601      	mov	r1, r0
20001924:	4662      	mov	r2, ip
20001926:	6820      	ldr	r0, [r4, #0]
20001928:	bc10      	pop	{r4}
2000192a:	f7fe bf97 	b.w	2000085c <_write_r>
2000192e:	bf00      	nop

20001930 <_malloc_trim_r>:
20001930:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
20001932:	f242 34b4 	movw	r4, #9140	; 0x23b4
20001936:	f2c2 0400 	movt	r4, #8192	; 0x2000
2000193a:	460f      	mov	r7, r1
2000193c:	4605      	mov	r5, r0
2000193e:	f000 fbfd 	bl	2000213c <__malloc_lock>
20001942:	68a3      	ldr	r3, [r4, #8]
20001944:	685e      	ldr	r6, [r3, #4]
20001946:	f026 0603 	bic.w	r6, r6, #3
2000194a:	f506 637e 	add.w	r3, r6, #4064	; 0xfe0
2000194e:	330f      	adds	r3, #15
20001950:	1bdf      	subs	r7, r3, r7
20001952:	0b3f      	lsrs	r7, r7, #12
20001954:	3f01      	subs	r7, #1
20001956:	033f      	lsls	r7, r7, #12
20001958:	f5b7 5f80 	cmp.w	r7, #4096	; 0x1000
2000195c:	db07      	blt.n	2000196e <_malloc_trim_r+0x3e>
2000195e:	2100      	movs	r1, #0
20001960:	4628      	mov	r0, r5
20001962:	f000 fbef 	bl	20002144 <_sbrk_r>
20001966:	68a3      	ldr	r3, [r4, #8]
20001968:	18f3      	adds	r3, r6, r3
2000196a:	4283      	cmp	r3, r0
2000196c:	d004      	beq.n	20001978 <_malloc_trim_r+0x48>
2000196e:	4628      	mov	r0, r5
20001970:	f000 fbe6 	bl	20002140 <__malloc_unlock>
20001974:	2000      	movs	r0, #0
20001976:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
20001978:	4279      	negs	r1, r7
2000197a:	4628      	mov	r0, r5
2000197c:	f000 fbe2 	bl	20002144 <_sbrk_r>
20001980:	f1b0 3fff 	cmp.w	r0, #4294967295
20001984:	d010      	beq.n	200019a8 <_malloc_trim_r+0x78>
20001986:	68a2      	ldr	r2, [r4, #8]
20001988:	f242 73d4 	movw	r3, #10196	; 0x27d4
2000198c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001990:	1bf6      	subs	r6, r6, r7
20001992:	f046 0601 	orr.w	r6, r6, #1
20001996:	4628      	mov	r0, r5
20001998:	6056      	str	r6, [r2, #4]
2000199a:	681a      	ldr	r2, [r3, #0]
2000199c:	1bd7      	subs	r7, r2, r7
2000199e:	601f      	str	r7, [r3, #0]
200019a0:	f000 fbce 	bl	20002140 <__malloc_unlock>
200019a4:	2001      	movs	r0, #1
200019a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
200019a8:	2100      	movs	r1, #0
200019aa:	4628      	mov	r0, r5
200019ac:	f000 fbca 	bl	20002144 <_sbrk_r>
200019b0:	68a3      	ldr	r3, [r4, #8]
200019b2:	1ac2      	subs	r2, r0, r3
200019b4:	2a0f      	cmp	r2, #15
200019b6:	ddda      	ble.n	2000196e <_malloc_trim_r+0x3e>
200019b8:	f242 74bc 	movw	r4, #10172	; 0x27bc
200019bc:	f242 71d4 	movw	r1, #10196	; 0x27d4
200019c0:	f2c2 0400 	movt	r4, #8192	; 0x2000
200019c4:	f2c2 0100 	movt	r1, #8192	; 0x2000
200019c8:	f042 0201 	orr.w	r2, r2, #1
200019cc:	6824      	ldr	r4, [r4, #0]
200019ce:	1b00      	subs	r0, r0, r4
200019d0:	6008      	str	r0, [r1, #0]
200019d2:	605a      	str	r2, [r3, #4]
200019d4:	e7cb      	b.n	2000196e <_malloc_trim_r+0x3e>
200019d6:	bf00      	nop

200019d8 <_free_r>:
200019d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
200019dc:	4605      	mov	r5, r0
200019de:	460c      	mov	r4, r1
200019e0:	2900      	cmp	r1, #0
200019e2:	f000 8088 	beq.w	20001af6 <_free_r+0x11e>
200019e6:	f000 fba9 	bl	2000213c <__malloc_lock>
200019ea:	f1a4 0208 	sub.w	r2, r4, #8
200019ee:	f242 30b4 	movw	r0, #9140	; 0x23b4
200019f2:	6856      	ldr	r6, [r2, #4]
200019f4:	f2c2 0000 	movt	r0, #8192	; 0x2000
200019f8:	f026 0301 	bic.w	r3, r6, #1
200019fc:	f8d0 c008 	ldr.w	ip, [r0, #8]
20001a00:	18d1      	adds	r1, r2, r3
20001a02:	458c      	cmp	ip, r1
20001a04:	684f      	ldr	r7, [r1, #4]
20001a06:	f027 0703 	bic.w	r7, r7, #3
20001a0a:	f000 8095 	beq.w	20001b38 <_free_r+0x160>
20001a0e:	f016 0601 	ands.w	r6, r6, #1
20001a12:	604f      	str	r7, [r1, #4]
20001a14:	d05f      	beq.n	20001ad6 <_free_r+0xfe>
20001a16:	2600      	movs	r6, #0
20001a18:	19cc      	adds	r4, r1, r7
20001a1a:	6864      	ldr	r4, [r4, #4]
20001a1c:	f014 0f01 	tst.w	r4, #1
20001a20:	d106      	bne.n	20001a30 <_free_r+0x58>
20001a22:	19db      	adds	r3, r3, r7
20001a24:	2e00      	cmp	r6, #0
20001a26:	d07a      	beq.n	20001b1e <_free_r+0x146>
20001a28:	688c      	ldr	r4, [r1, #8]
20001a2a:	68c9      	ldr	r1, [r1, #12]
20001a2c:	608c      	str	r4, [r1, #8]
20001a2e:	60e1      	str	r1, [r4, #12]
20001a30:	f043 0101 	orr.w	r1, r3, #1
20001a34:	50d3      	str	r3, [r2, r3]
20001a36:	6051      	str	r1, [r2, #4]
20001a38:	2e00      	cmp	r6, #0
20001a3a:	d147      	bne.n	20001acc <_free_r+0xf4>
20001a3c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
20001a40:	d35b      	bcc.n	20001afa <_free_r+0x122>
20001a42:	0a59      	lsrs	r1, r3, #9
20001a44:	2904      	cmp	r1, #4
20001a46:	bf9e      	ittt	ls
20001a48:	ea4f 1c93 	movls.w	ip, r3, lsr #6
20001a4c:	f10c 0c38 	addls.w	ip, ip, #56	; 0x38
20001a50:	ea4f 04cc 	movls.w	r4, ip, lsl #3
20001a54:	d928      	bls.n	20001aa8 <_free_r+0xd0>
20001a56:	2914      	cmp	r1, #20
20001a58:	bf9c      	itt	ls
20001a5a:	f101 0c5b 	addls.w	ip, r1, #91	; 0x5b
20001a5e:	ea4f 04cc 	movls.w	r4, ip, lsl #3
20001a62:	d921      	bls.n	20001aa8 <_free_r+0xd0>
20001a64:	2954      	cmp	r1, #84	; 0x54
20001a66:	bf9e      	ittt	ls
20001a68:	ea4f 3c13 	movls.w	ip, r3, lsr #12
20001a6c:	f10c 0c6e 	addls.w	ip, ip, #110	; 0x6e
20001a70:	ea4f 04cc 	movls.w	r4, ip, lsl #3
20001a74:	d918      	bls.n	20001aa8 <_free_r+0xd0>
20001a76:	f5b1 7faa 	cmp.w	r1, #340	; 0x154
20001a7a:	bf9e      	ittt	ls
20001a7c:	ea4f 3cd3 	movls.w	ip, r3, lsr #15
20001a80:	f10c 0c77 	addls.w	ip, ip, #119	; 0x77
20001a84:	ea4f 04cc 	movls.w	r4, ip, lsl #3
20001a88:	d90e      	bls.n	20001aa8 <_free_r+0xd0>
20001a8a:	f240 5c54 	movw	ip, #1364	; 0x554
20001a8e:	4561      	cmp	r1, ip
20001a90:	bf95      	itete	ls
20001a92:	ea4f 4c93 	movls.w	ip, r3, lsr #18
20001a96:	f44f 747c 	movhi.w	r4, #1008	; 0x3f0
20001a9a:	f10c 0c7c 	addls.w	ip, ip, #124	; 0x7c
20001a9e:	f04f 0c7e 	movhi.w	ip, #126	; 0x7e
20001aa2:	bf98      	it	ls
20001aa4:	ea4f 04cc 	movls.w	r4, ip, lsl #3
20001aa8:	1904      	adds	r4, r0, r4
20001aaa:	68a1      	ldr	r1, [r4, #8]
20001aac:	42a1      	cmp	r1, r4
20001aae:	d103      	bne.n	20001ab8 <_free_r+0xe0>
20001ab0:	e064      	b.n	20001b7c <_free_r+0x1a4>
20001ab2:	6889      	ldr	r1, [r1, #8]
20001ab4:	428c      	cmp	r4, r1
20001ab6:	d004      	beq.n	20001ac2 <_free_r+0xea>
20001ab8:	6848      	ldr	r0, [r1, #4]
20001aba:	f020 0003 	bic.w	r0, r0, #3
20001abe:	4283      	cmp	r3, r0
20001ac0:	d3f7      	bcc.n	20001ab2 <_free_r+0xda>
20001ac2:	68cb      	ldr	r3, [r1, #12]
20001ac4:	60d3      	str	r3, [r2, #12]
20001ac6:	6091      	str	r1, [r2, #8]
20001ac8:	60ca      	str	r2, [r1, #12]
20001aca:	609a      	str	r2, [r3, #8]
20001acc:	4628      	mov	r0, r5
20001ace:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
20001ad2:	f000 bb35 	b.w	20002140 <__malloc_unlock>
20001ad6:	f854 4c08 	ldr.w	r4, [r4, #-8]
20001ada:	f100 0c08 	add.w	ip, r0, #8
20001ade:	1b12      	subs	r2, r2, r4
20001ae0:	191b      	adds	r3, r3, r4
20001ae2:	6894      	ldr	r4, [r2, #8]
20001ae4:	4564      	cmp	r4, ip
20001ae6:	d047      	beq.n	20001b78 <_free_r+0x1a0>
20001ae8:	f8d2 c00c 	ldr.w	ip, [r2, #12]
20001aec:	f8cc 4008 	str.w	r4, [ip, #8]
20001af0:	f8c4 c00c 	str.w	ip, [r4, #12]
20001af4:	e790      	b.n	20001a18 <_free_r+0x40>
20001af6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
20001afa:	08db      	lsrs	r3, r3, #3
20001afc:	f04f 0c01 	mov.w	ip, #1
20001b00:	6846      	ldr	r6, [r0, #4]
20001b02:	eb00 01c3 	add.w	r1, r0, r3, lsl #3
20001b06:	109b      	asrs	r3, r3, #2
20001b08:	fa0c f303 	lsl.w	r3, ip, r3
20001b0c:	60d1      	str	r1, [r2, #12]
20001b0e:	688c      	ldr	r4, [r1, #8]
20001b10:	ea46 0303 	orr.w	r3, r6, r3
20001b14:	6043      	str	r3, [r0, #4]
20001b16:	6094      	str	r4, [r2, #8]
20001b18:	60e2      	str	r2, [r4, #12]
20001b1a:	608a      	str	r2, [r1, #8]
20001b1c:	e7d6      	b.n	20001acc <_free_r+0xf4>
20001b1e:	688c      	ldr	r4, [r1, #8]
20001b20:	4f1c      	ldr	r7, [pc, #112]	; (20001b94 <_free_r+0x1bc>)
20001b22:	42bc      	cmp	r4, r7
20001b24:	d181      	bne.n	20001a2a <_free_r+0x52>
20001b26:	50d3      	str	r3, [r2, r3]
20001b28:	f043 0301 	orr.w	r3, r3, #1
20001b2c:	60e2      	str	r2, [r4, #12]
20001b2e:	60a2      	str	r2, [r4, #8]
20001b30:	6053      	str	r3, [r2, #4]
20001b32:	6094      	str	r4, [r2, #8]
20001b34:	60d4      	str	r4, [r2, #12]
20001b36:	e7c9      	b.n	20001acc <_free_r+0xf4>
20001b38:	18fb      	adds	r3, r7, r3
20001b3a:	f016 0f01 	tst.w	r6, #1
20001b3e:	d107      	bne.n	20001b50 <_free_r+0x178>
20001b40:	f854 1c08 	ldr.w	r1, [r4, #-8]
20001b44:	1a52      	subs	r2, r2, r1
20001b46:	185b      	adds	r3, r3, r1
20001b48:	68d4      	ldr	r4, [r2, #12]
20001b4a:	6891      	ldr	r1, [r2, #8]
20001b4c:	60a1      	str	r1, [r4, #8]
20001b4e:	60cc      	str	r4, [r1, #12]
20001b50:	f242 71c0 	movw	r1, #10176	; 0x27c0
20001b54:	6082      	str	r2, [r0, #8]
20001b56:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001b5a:	f043 0001 	orr.w	r0, r3, #1
20001b5e:	6050      	str	r0, [r2, #4]
20001b60:	680a      	ldr	r2, [r1, #0]
20001b62:	4293      	cmp	r3, r2
20001b64:	d3b2      	bcc.n	20001acc <_free_r+0xf4>
20001b66:	f242 73d0 	movw	r3, #10192	; 0x27d0
20001b6a:	4628      	mov	r0, r5
20001b6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001b70:	6819      	ldr	r1, [r3, #0]
20001b72:	f7ff fedd 	bl	20001930 <_malloc_trim_r>
20001b76:	e7a9      	b.n	20001acc <_free_r+0xf4>
20001b78:	2601      	movs	r6, #1
20001b7a:	e74d      	b.n	20001a18 <_free_r+0x40>
20001b7c:	2601      	movs	r6, #1
20001b7e:	6844      	ldr	r4, [r0, #4]
20001b80:	ea4f 0cac 	mov.w	ip, ip, asr #2
20001b84:	460b      	mov	r3, r1
20001b86:	fa06 fc0c 	lsl.w	ip, r6, ip
20001b8a:	ea44 040c 	orr.w	r4, r4, ip
20001b8e:	6044      	str	r4, [r0, #4]
20001b90:	e798      	b.n	20001ac4 <_free_r+0xec>
20001b92:	bf00      	nop
20001b94:	200023bc 	.word	0x200023bc

20001b98 <_malloc_r>:
20001b98:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
20001b9c:	f101 040b 	add.w	r4, r1, #11
20001ba0:	2c16      	cmp	r4, #22
20001ba2:	b083      	sub	sp, #12
20001ba4:	4606      	mov	r6, r0
20001ba6:	d82f      	bhi.n	20001c08 <_malloc_r+0x70>
20001ba8:	2300      	movs	r3, #0
20001baa:	2410      	movs	r4, #16
20001bac:	428c      	cmp	r4, r1
20001bae:	bf2c      	ite	cs
20001bb0:	4619      	movcs	r1, r3
20001bb2:	f043 0101 	orrcc.w	r1, r3, #1
20001bb6:	2900      	cmp	r1, #0
20001bb8:	d130      	bne.n	20001c1c <_malloc_r+0x84>
20001bba:	4630      	mov	r0, r6
20001bbc:	f000 fabe 	bl	2000213c <__malloc_lock>
20001bc0:	f5b4 7ffc 	cmp.w	r4, #504	; 0x1f8
20001bc4:	d22e      	bcs.n	20001c24 <_malloc_r+0x8c>
20001bc6:	ea4f 0ed4 	mov.w	lr, r4, lsr #3
20001bca:	f242 35b4 	movw	r5, #9140	; 0x23b4
20001bce:	f2c2 0500 	movt	r5, #8192	; 0x2000
20001bd2:	eb05 02ce 	add.w	r2, r5, lr, lsl #3
20001bd6:	68d3      	ldr	r3, [r2, #12]
20001bd8:	4293      	cmp	r3, r2
20001bda:	f000 8206 	beq.w	20001fea <_malloc_r+0x452>
20001bde:	685a      	ldr	r2, [r3, #4]
20001be0:	f103 0508 	add.w	r5, r3, #8
20001be4:	68d9      	ldr	r1, [r3, #12]
20001be6:	4630      	mov	r0, r6
20001be8:	f022 0c03 	bic.w	ip, r2, #3
20001bec:	689a      	ldr	r2, [r3, #8]
20001bee:	4463      	add	r3, ip
20001bf0:	685c      	ldr	r4, [r3, #4]
20001bf2:	608a      	str	r2, [r1, #8]
20001bf4:	f044 0401 	orr.w	r4, r4, #1
20001bf8:	60d1      	str	r1, [r2, #12]
20001bfa:	605c      	str	r4, [r3, #4]
20001bfc:	f000 faa0 	bl	20002140 <__malloc_unlock>
20001c00:	4628      	mov	r0, r5
20001c02:	b003      	add	sp, #12
20001c04:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
20001c08:	f024 0407 	bic.w	r4, r4, #7
20001c0c:	0fe3      	lsrs	r3, r4, #31
20001c0e:	428c      	cmp	r4, r1
20001c10:	bf2c      	ite	cs
20001c12:	4619      	movcs	r1, r3
20001c14:	f043 0101 	orrcc.w	r1, r3, #1
20001c18:	2900      	cmp	r1, #0
20001c1a:	d0ce      	beq.n	20001bba <_malloc_r+0x22>
20001c1c:	230c      	movs	r3, #12
20001c1e:	2500      	movs	r5, #0
20001c20:	6033      	str	r3, [r6, #0]
20001c22:	e7ed      	b.n	20001c00 <_malloc_r+0x68>
20001c24:	ea5f 2e54 	movs.w	lr, r4, lsr #9
20001c28:	bf04      	itt	eq
20001c2a:	ea4f 0ed4 	moveq.w	lr, r4, lsr #3
20001c2e:	ea4f 00ce 	moveq.w	r0, lr, lsl #3
20001c32:	f040 8090 	bne.w	20001d56 <_malloc_r+0x1be>
20001c36:	f242 35b4 	movw	r5, #9140	; 0x23b4
20001c3a:	f2c2 0500 	movt	r5, #8192	; 0x2000
20001c3e:	1828      	adds	r0, r5, r0
20001c40:	68c3      	ldr	r3, [r0, #12]
20001c42:	4298      	cmp	r0, r3
20001c44:	d106      	bne.n	20001c54 <_malloc_r+0xbc>
20001c46:	e00d      	b.n	20001c64 <_malloc_r+0xcc>
20001c48:	2a00      	cmp	r2, #0
20001c4a:	f280 816f 	bge.w	20001f2c <_malloc_r+0x394>
20001c4e:	68db      	ldr	r3, [r3, #12]
20001c50:	4298      	cmp	r0, r3
20001c52:	d007      	beq.n	20001c64 <_malloc_r+0xcc>
20001c54:	6859      	ldr	r1, [r3, #4]
20001c56:	f021 0103 	bic.w	r1, r1, #3
20001c5a:	1b0a      	subs	r2, r1, r4
20001c5c:	2a0f      	cmp	r2, #15
20001c5e:	ddf3      	ble.n	20001c48 <_malloc_r+0xb0>
20001c60:	f10e 3eff 	add.w	lr, lr, #4294967295
20001c64:	f10e 0e01 	add.w	lr, lr, #1
20001c68:	f242 37b4 	movw	r7, #9140	; 0x23b4
20001c6c:	f2c2 0700 	movt	r7, #8192	; 0x2000
20001c70:	f107 0108 	add.w	r1, r7, #8
20001c74:	688b      	ldr	r3, [r1, #8]
20001c76:	4299      	cmp	r1, r3
20001c78:	bf08      	it	eq
20001c7a:	687a      	ldreq	r2, [r7, #4]
20001c7c:	d026      	beq.n	20001ccc <_malloc_r+0x134>
20001c7e:	685a      	ldr	r2, [r3, #4]
20001c80:	f022 0c03 	bic.w	ip, r2, #3
20001c84:	ebc4 020c 	rsb	r2, r4, ip
20001c88:	2a0f      	cmp	r2, #15
20001c8a:	f300 8194 	bgt.w	20001fb6 <_malloc_r+0x41e>
20001c8e:	2a00      	cmp	r2, #0
20001c90:	60c9      	str	r1, [r1, #12]
20001c92:	6089      	str	r1, [r1, #8]
20001c94:	f280 8099 	bge.w	20001dca <_malloc_r+0x232>
20001c98:	f5bc 7f00 	cmp.w	ip, #512	; 0x200
20001c9c:	f080 8165 	bcs.w	20001f6a <_malloc_r+0x3d2>
20001ca0:	ea4f 0cdc 	mov.w	ip, ip, lsr #3
20001ca4:	f04f 0a01 	mov.w	sl, #1
20001ca8:	687a      	ldr	r2, [r7, #4]
20001caa:	eb07 00cc 	add.w	r0, r7, ip, lsl #3
20001cae:	ea4f 0cac 	mov.w	ip, ip, asr #2
20001cb2:	fa0a fc0c 	lsl.w	ip, sl, ip
20001cb6:	60d8      	str	r0, [r3, #12]
20001cb8:	f8d0 8008 	ldr.w	r8, [r0, #8]
20001cbc:	ea4c 0202 	orr.w	r2, ip, r2
20001cc0:	607a      	str	r2, [r7, #4]
20001cc2:	f8c3 8008 	str.w	r8, [r3, #8]
20001cc6:	f8c8 300c 	str.w	r3, [r8, #12]
20001cca:	6083      	str	r3, [r0, #8]
20001ccc:	f04f 0c01 	mov.w	ip, #1
20001cd0:	ea4f 03ae 	mov.w	r3, lr, asr #2
20001cd4:	fa0c fc03 	lsl.w	ip, ip, r3
20001cd8:	4594      	cmp	ip, r2
20001cda:	f200 8082 	bhi.w	20001de2 <_malloc_r+0x24a>
20001cde:	ea12 0f0c 	tst.w	r2, ip
20001ce2:	d108      	bne.n	20001cf6 <_malloc_r+0x15e>
20001ce4:	f02e 0e03 	bic.w	lr, lr, #3
20001ce8:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
20001cec:	f10e 0e04 	add.w	lr, lr, #4
20001cf0:	ea12 0f0c 	tst.w	r2, ip
20001cf4:	d0f8      	beq.n	20001ce8 <_malloc_r+0x150>
20001cf6:	eb07 09ce 	add.w	r9, r7, lr, lsl #3
20001cfa:	46f2      	mov	sl, lr
20001cfc:	46c8      	mov	r8, r9
20001cfe:	f8d8 300c 	ldr.w	r3, [r8, #12]
20001d02:	4598      	cmp	r8, r3
20001d04:	d107      	bne.n	20001d16 <_malloc_r+0x17e>
20001d06:	e168      	b.n	20001fda <_malloc_r+0x442>
20001d08:	2a00      	cmp	r2, #0
20001d0a:	f280 8178 	bge.w	20001ffe <_malloc_r+0x466>
20001d0e:	68db      	ldr	r3, [r3, #12]
20001d10:	4598      	cmp	r8, r3
20001d12:	f000 8162 	beq.w	20001fda <_malloc_r+0x442>
20001d16:	6858      	ldr	r0, [r3, #4]
20001d18:	f020 0003 	bic.w	r0, r0, #3
20001d1c:	1b02      	subs	r2, r0, r4
20001d1e:	2a0f      	cmp	r2, #15
20001d20:	ddf2      	ble.n	20001d08 <_malloc_r+0x170>
20001d22:	461d      	mov	r5, r3
20001d24:	191f      	adds	r7, r3, r4
20001d26:	f8d3 c00c 	ldr.w	ip, [r3, #12]
20001d2a:	f044 0e01 	orr.w	lr, r4, #1
20001d2e:	f855 4f08 	ldr.w	r4, [r5, #8]!
20001d32:	4630      	mov	r0, r6
20001d34:	50ba      	str	r2, [r7, r2]
20001d36:	f042 0201 	orr.w	r2, r2, #1
20001d3a:	f8c3 e004 	str.w	lr, [r3, #4]
20001d3e:	f8cc 4008 	str.w	r4, [ip, #8]
20001d42:	f8c4 c00c 	str.w	ip, [r4, #12]
20001d46:	608f      	str	r7, [r1, #8]
20001d48:	60cf      	str	r7, [r1, #12]
20001d4a:	607a      	str	r2, [r7, #4]
20001d4c:	60b9      	str	r1, [r7, #8]
20001d4e:	60f9      	str	r1, [r7, #12]
20001d50:	f000 f9f6 	bl	20002140 <__malloc_unlock>
20001d54:	e754      	b.n	20001c00 <_malloc_r+0x68>
20001d56:	f1be 0f04 	cmp.w	lr, #4
20001d5a:	bf9e      	ittt	ls
20001d5c:	ea4f 1e94 	movls.w	lr, r4, lsr #6
20001d60:	f10e 0e38 	addls.w	lr, lr, #56	; 0x38
20001d64:	ea4f 00ce 	movls.w	r0, lr, lsl #3
20001d68:	f67f af65 	bls.w	20001c36 <_malloc_r+0x9e>
20001d6c:	f1be 0f14 	cmp.w	lr, #20
20001d70:	bf9c      	itt	ls
20001d72:	f10e 0e5b 	addls.w	lr, lr, #91	; 0x5b
20001d76:	ea4f 00ce 	movls.w	r0, lr, lsl #3
20001d7a:	f67f af5c 	bls.w	20001c36 <_malloc_r+0x9e>
20001d7e:	f1be 0f54 	cmp.w	lr, #84	; 0x54
20001d82:	bf9e      	ittt	ls
20001d84:	ea4f 3e14 	movls.w	lr, r4, lsr #12
20001d88:	f10e 0e6e 	addls.w	lr, lr, #110	; 0x6e
20001d8c:	ea4f 00ce 	movls.w	r0, lr, lsl #3
20001d90:	f67f af51 	bls.w	20001c36 <_malloc_r+0x9e>
20001d94:	f5be 7faa 	cmp.w	lr, #340	; 0x154
20001d98:	bf9e      	ittt	ls
20001d9a:	ea4f 3ed4 	movls.w	lr, r4, lsr #15
20001d9e:	f10e 0e77 	addls.w	lr, lr, #119	; 0x77
20001da2:	ea4f 00ce 	movls.w	r0, lr, lsl #3
20001da6:	f67f af46 	bls.w	20001c36 <_malloc_r+0x9e>
20001daa:	f240 5354 	movw	r3, #1364	; 0x554
20001dae:	459e      	cmp	lr, r3
20001db0:	bf95      	itete	ls
20001db2:	ea4f 4e94 	movls.w	lr, r4, lsr #18
20001db6:	f44f 707c 	movhi.w	r0, #1008	; 0x3f0
20001dba:	f10e 0e7c 	addls.w	lr, lr, #124	; 0x7c
20001dbe:	f04f 0e7e 	movhi.w	lr, #126	; 0x7e
20001dc2:	bf98      	it	ls
20001dc4:	ea4f 00ce 	movls.w	r0, lr, lsl #3
20001dc8:	e735      	b.n	20001c36 <_malloc_r+0x9e>
20001dca:	eb03 020c 	add.w	r2, r3, ip
20001dce:	f103 0508 	add.w	r5, r3, #8
20001dd2:	4630      	mov	r0, r6
20001dd4:	6853      	ldr	r3, [r2, #4]
20001dd6:	f043 0301 	orr.w	r3, r3, #1
20001dda:	6053      	str	r3, [r2, #4]
20001ddc:	f000 f9b0 	bl	20002140 <__malloc_unlock>
20001de0:	e70e      	b.n	20001c00 <_malloc_r+0x68>
20001de2:	f8d7 8008 	ldr.w	r8, [r7, #8]
20001de6:	f8d8 3004 	ldr.w	r3, [r8, #4]
20001dea:	f023 0903 	bic.w	r9, r3, #3
20001dee:	ebc4 0209 	rsb	r2, r4, r9
20001df2:	454c      	cmp	r4, r9
20001df4:	bf94      	ite	ls
20001df6:	2300      	movls	r3, #0
20001df8:	2301      	movhi	r3, #1
20001dfa:	2a0f      	cmp	r2, #15
20001dfc:	bfd8      	it	le
20001dfe:	f043 0301 	orrle.w	r3, r3, #1
20001e02:	2b00      	cmp	r3, #0
20001e04:	f000 80a1 	beq.w	20001f4a <_malloc_r+0x3b2>
20001e08:	f242 7bd0 	movw	fp, #10192	; 0x27d0
20001e0c:	f8d5 2408 	ldr.w	r2, [r5, #1032]	; 0x408
20001e10:	f2c2 0b00 	movt	fp, #8192	; 0x2000
20001e14:	f8db 3000 	ldr.w	r3, [fp]
20001e18:	3310      	adds	r3, #16
20001e1a:	191b      	adds	r3, r3, r4
20001e1c:	f1b2 3fff 	cmp.w	r2, #4294967295
20001e20:	d006      	beq.n	20001e30 <_malloc_r+0x298>
20001e22:	f503 637e 	add.w	r3, r3, #4064	; 0xfe0
20001e26:	331f      	adds	r3, #31
20001e28:	f423 637e 	bic.w	r3, r3, #4064	; 0xfe0
20001e2c:	f023 031f 	bic.w	r3, r3, #31
20001e30:	4619      	mov	r1, r3
20001e32:	4630      	mov	r0, r6
20001e34:	9301      	str	r3, [sp, #4]
20001e36:	f000 f985 	bl	20002144 <_sbrk_r>
20001e3a:	9b01      	ldr	r3, [sp, #4]
20001e3c:	f1b0 3fff 	cmp.w	r0, #4294967295
20001e40:	4682      	mov	sl, r0
20001e42:	f000 80f4 	beq.w	2000202e <_malloc_r+0x496>
20001e46:	eb08 0109 	add.w	r1, r8, r9
20001e4a:	4281      	cmp	r1, r0
20001e4c:	f200 80ec 	bhi.w	20002028 <_malloc_r+0x490>
20001e50:	f8db 2004 	ldr.w	r2, [fp, #4]
20001e54:	189a      	adds	r2, r3, r2
20001e56:	4551      	cmp	r1, sl
20001e58:	f8cb 2004 	str.w	r2, [fp, #4]
20001e5c:	f000 8145 	beq.w	200020ea <_malloc_r+0x552>
20001e60:	f8d5 5408 	ldr.w	r5, [r5, #1032]	; 0x408
20001e64:	f242 30b4 	movw	r0, #9140	; 0x23b4
20001e68:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001e6c:	f1b5 3fff 	cmp.w	r5, #4294967295
20001e70:	bf08      	it	eq
20001e72:	f8c0 a408 	streq.w	sl, [r0, #1032]	; 0x408
20001e76:	d003      	beq.n	20001e80 <_malloc_r+0x2e8>
20001e78:	4452      	add	r2, sl
20001e7a:	1a51      	subs	r1, r2, r1
20001e7c:	f8cb 1004 	str.w	r1, [fp, #4]
20001e80:	f01a 0507 	ands.w	r5, sl, #7
20001e84:	4630      	mov	r0, r6
20001e86:	bf17      	itett	ne
20001e88:	f1c5 0508 	rsbne	r5, r5, #8
20001e8c:	f44f 5580 	moveq.w	r5, #4096	; 0x1000
20001e90:	44aa      	addne	sl, r5
20001e92:	f505 5580 	addne.w	r5, r5, #4096	; 0x1000
20001e96:	4453      	add	r3, sl
20001e98:	051b      	lsls	r3, r3, #20
20001e9a:	0d1b      	lsrs	r3, r3, #20
20001e9c:	1aed      	subs	r5, r5, r3
20001e9e:	4629      	mov	r1, r5
20001ea0:	f000 f950 	bl	20002144 <_sbrk_r>
20001ea4:	f1b0 3fff 	cmp.w	r0, #4294967295
20001ea8:	f000 812c 	beq.w	20002104 <_malloc_r+0x56c>
20001eac:	ebca 0100 	rsb	r1, sl, r0
20001eb0:	1949      	adds	r1, r1, r5
20001eb2:	f041 0101 	orr.w	r1, r1, #1
20001eb6:	f8db 2004 	ldr.w	r2, [fp, #4]
20001eba:	f242 73d0 	movw	r3, #10192	; 0x27d0
20001ebe:	f8c7 a008 	str.w	sl, [r7, #8]
20001ec2:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001ec6:	18aa      	adds	r2, r5, r2
20001ec8:	45b8      	cmp	r8, r7
20001eca:	f8cb 2004 	str.w	r2, [fp, #4]
20001ece:	f8ca 1004 	str.w	r1, [sl, #4]
20001ed2:	d017      	beq.n	20001f04 <_malloc_r+0x36c>
20001ed4:	f1b9 0f0f 	cmp.w	r9, #15
20001ed8:	f240 80df 	bls.w	2000209a <_malloc_r+0x502>
20001edc:	f1a9 010c 	sub.w	r1, r9, #12
20001ee0:	2505      	movs	r5, #5
20001ee2:	f021 0107 	bic.w	r1, r1, #7
20001ee6:	eb08 0001 	add.w	r0, r8, r1
20001eea:	290f      	cmp	r1, #15
20001eec:	6085      	str	r5, [r0, #8]
20001eee:	6045      	str	r5, [r0, #4]
20001ef0:	f8d8 0004 	ldr.w	r0, [r8, #4]
20001ef4:	f000 0001 	and.w	r0, r0, #1
20001ef8:	ea41 0000 	orr.w	r0, r1, r0
20001efc:	f8c8 0004 	str.w	r0, [r8, #4]
20001f00:	f200 80ac 	bhi.w	2000205c <_malloc_r+0x4c4>
20001f04:	46d0      	mov	r8, sl
20001f06:	f242 73d0 	movw	r3, #10192	; 0x27d0
20001f0a:	f8db 102c 	ldr.w	r1, [fp, #44]	; 0x2c
20001f0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001f12:	428a      	cmp	r2, r1
20001f14:	f8db 1030 	ldr.w	r1, [fp, #48]	; 0x30
20001f18:	bf88      	it	hi
20001f1a:	62da      	strhi	r2, [r3, #44]	; 0x2c
20001f1c:	f242 73d0 	movw	r3, #10192	; 0x27d0
20001f20:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001f24:	428a      	cmp	r2, r1
20001f26:	bf88      	it	hi
20001f28:	631a      	strhi	r2, [r3, #48]	; 0x30
20001f2a:	e082      	b.n	20002032 <_malloc_r+0x49a>
20001f2c:	185c      	adds	r4, r3, r1
20001f2e:	689a      	ldr	r2, [r3, #8]
20001f30:	68d9      	ldr	r1, [r3, #12]
20001f32:	4630      	mov	r0, r6
20001f34:	6866      	ldr	r6, [r4, #4]
20001f36:	f103 0508 	add.w	r5, r3, #8
20001f3a:	608a      	str	r2, [r1, #8]
20001f3c:	f046 0301 	orr.w	r3, r6, #1
20001f40:	60d1      	str	r1, [r2, #12]
20001f42:	6063      	str	r3, [r4, #4]
20001f44:	f000 f8fc 	bl	20002140 <__malloc_unlock>
20001f48:	e65a      	b.n	20001c00 <_malloc_r+0x68>
20001f4a:	eb08 0304 	add.w	r3, r8, r4
20001f4e:	f042 0201 	orr.w	r2, r2, #1
20001f52:	f044 0401 	orr.w	r4, r4, #1
20001f56:	4630      	mov	r0, r6
20001f58:	f8c8 4004 	str.w	r4, [r8, #4]
20001f5c:	f108 0508 	add.w	r5, r8, #8
20001f60:	605a      	str	r2, [r3, #4]
20001f62:	60bb      	str	r3, [r7, #8]
20001f64:	f000 f8ec 	bl	20002140 <__malloc_unlock>
20001f68:	e64a      	b.n	20001c00 <_malloc_r+0x68>
20001f6a:	ea4f 225c 	mov.w	r2, ip, lsr #9
20001f6e:	2a04      	cmp	r2, #4
20001f70:	d954      	bls.n	2000201c <_malloc_r+0x484>
20001f72:	2a14      	cmp	r2, #20
20001f74:	f200 8089 	bhi.w	2000208a <_malloc_r+0x4f2>
20001f78:	325b      	adds	r2, #91	; 0x5b
20001f7a:	ea4f 08c2 	mov.w	r8, r2, lsl #3
20001f7e:	44a8      	add	r8, r5
20001f80:	f242 37b4 	movw	r7, #9140	; 0x23b4
20001f84:	f2c2 0700 	movt	r7, #8192	; 0x2000
20001f88:	f8d8 0008 	ldr.w	r0, [r8, #8]
20001f8c:	4540      	cmp	r0, r8
20001f8e:	d103      	bne.n	20001f98 <_malloc_r+0x400>
20001f90:	e06f      	b.n	20002072 <_malloc_r+0x4da>
20001f92:	6880      	ldr	r0, [r0, #8]
20001f94:	4580      	cmp	r8, r0
20001f96:	d004      	beq.n	20001fa2 <_malloc_r+0x40a>
20001f98:	6842      	ldr	r2, [r0, #4]
20001f9a:	f022 0203 	bic.w	r2, r2, #3
20001f9e:	4594      	cmp	ip, r2
20001fa0:	d3f7      	bcc.n	20001f92 <_malloc_r+0x3fa>
20001fa2:	f8d0 c00c 	ldr.w	ip, [r0, #12]
20001fa6:	f8c3 c00c 	str.w	ip, [r3, #12]
20001faa:	6098      	str	r0, [r3, #8]
20001fac:	687a      	ldr	r2, [r7, #4]
20001fae:	60c3      	str	r3, [r0, #12]
20001fb0:	f8cc 3008 	str.w	r3, [ip, #8]
20001fb4:	e68a      	b.n	20001ccc <_malloc_r+0x134>
20001fb6:	191f      	adds	r7, r3, r4
20001fb8:	4630      	mov	r0, r6
20001fba:	f044 0401 	orr.w	r4, r4, #1
20001fbe:	60cf      	str	r7, [r1, #12]
20001fc0:	605c      	str	r4, [r3, #4]
20001fc2:	f103 0508 	add.w	r5, r3, #8
20001fc6:	50ba      	str	r2, [r7, r2]
20001fc8:	f042 0201 	orr.w	r2, r2, #1
20001fcc:	608f      	str	r7, [r1, #8]
20001fce:	607a      	str	r2, [r7, #4]
20001fd0:	60b9      	str	r1, [r7, #8]
20001fd2:	60f9      	str	r1, [r7, #12]
20001fd4:	f000 f8b4 	bl	20002140 <__malloc_unlock>
20001fd8:	e612      	b.n	20001c00 <_malloc_r+0x68>
20001fda:	f10a 0a01 	add.w	sl, sl, #1
20001fde:	f01a 0f03 	tst.w	sl, #3
20001fe2:	d05f      	beq.n	200020a4 <_malloc_r+0x50c>
20001fe4:	f103 0808 	add.w	r8, r3, #8
20001fe8:	e689      	b.n	20001cfe <_malloc_r+0x166>
20001fea:	f103 0208 	add.w	r2, r3, #8
20001fee:	68d3      	ldr	r3, [r2, #12]
20001ff0:	429a      	cmp	r2, r3
20001ff2:	bf08      	it	eq
20001ff4:	f10e 0e02 	addeq.w	lr, lr, #2
20001ff8:	f43f ae36 	beq.w	20001c68 <_malloc_r+0xd0>
20001ffc:	e5ef      	b.n	20001bde <_malloc_r+0x46>
20001ffe:	461d      	mov	r5, r3
20002000:	1819      	adds	r1, r3, r0
20002002:	68da      	ldr	r2, [r3, #12]
20002004:	4630      	mov	r0, r6
20002006:	f855 3f08 	ldr.w	r3, [r5, #8]!
2000200a:	684c      	ldr	r4, [r1, #4]
2000200c:	6093      	str	r3, [r2, #8]
2000200e:	f044 0401 	orr.w	r4, r4, #1
20002012:	60da      	str	r2, [r3, #12]
20002014:	604c      	str	r4, [r1, #4]
20002016:	f000 f893 	bl	20002140 <__malloc_unlock>
2000201a:	e5f1      	b.n	20001c00 <_malloc_r+0x68>
2000201c:	ea4f 129c 	mov.w	r2, ip, lsr #6
20002020:	3238      	adds	r2, #56	; 0x38
20002022:	ea4f 08c2 	mov.w	r8, r2, lsl #3
20002026:	e7aa      	b.n	20001f7e <_malloc_r+0x3e6>
20002028:	45b8      	cmp	r8, r7
2000202a:	f43f af11 	beq.w	20001e50 <_malloc_r+0x2b8>
2000202e:	f8d7 8008 	ldr.w	r8, [r7, #8]
20002032:	f8d8 2004 	ldr.w	r2, [r8, #4]
20002036:	f022 0203 	bic.w	r2, r2, #3
2000203a:	4294      	cmp	r4, r2
2000203c:	bf94      	ite	ls
2000203e:	2300      	movls	r3, #0
20002040:	2301      	movhi	r3, #1
20002042:	1b12      	subs	r2, r2, r4
20002044:	2a0f      	cmp	r2, #15
20002046:	bfd8      	it	le
20002048:	f043 0301 	orrle.w	r3, r3, #1
2000204c:	2b00      	cmp	r3, #0
2000204e:	f43f af7c 	beq.w	20001f4a <_malloc_r+0x3b2>
20002052:	4630      	mov	r0, r6
20002054:	2500      	movs	r5, #0
20002056:	f000 f873 	bl	20002140 <__malloc_unlock>
2000205a:	e5d1      	b.n	20001c00 <_malloc_r+0x68>
2000205c:	f108 0108 	add.w	r1, r8, #8
20002060:	4630      	mov	r0, r6
20002062:	9301      	str	r3, [sp, #4]
20002064:	f7ff fcb8 	bl	200019d8 <_free_r>
20002068:	9b01      	ldr	r3, [sp, #4]
2000206a:	f8d7 8008 	ldr.w	r8, [r7, #8]
2000206e:	685a      	ldr	r2, [r3, #4]
20002070:	e749      	b.n	20001f06 <_malloc_r+0x36e>
20002072:	f04f 0a01 	mov.w	sl, #1
20002076:	f8d7 8004 	ldr.w	r8, [r7, #4]
2000207a:	1092      	asrs	r2, r2, #2
2000207c:	4684      	mov	ip, r0
2000207e:	fa0a f202 	lsl.w	r2, sl, r2
20002082:	ea48 0202 	orr.w	r2, r8, r2
20002086:	607a      	str	r2, [r7, #4]
20002088:	e78d      	b.n	20001fa6 <_malloc_r+0x40e>
2000208a:	2a54      	cmp	r2, #84	; 0x54
2000208c:	d824      	bhi.n	200020d8 <_malloc_r+0x540>
2000208e:	ea4f 321c 	mov.w	r2, ip, lsr #12
20002092:	326e      	adds	r2, #110	; 0x6e
20002094:	ea4f 08c2 	mov.w	r8, r2, lsl #3
20002098:	e771      	b.n	20001f7e <_malloc_r+0x3e6>
2000209a:	2301      	movs	r3, #1
2000209c:	46d0      	mov	r8, sl
2000209e:	f8ca 3004 	str.w	r3, [sl, #4]
200020a2:	e7c6      	b.n	20002032 <_malloc_r+0x49a>
200020a4:	464a      	mov	r2, r9
200020a6:	f01e 0f03 	tst.w	lr, #3
200020aa:	4613      	mov	r3, r2
200020ac:	f10e 3eff 	add.w	lr, lr, #4294967295
200020b0:	d033      	beq.n	2000211a <_malloc_r+0x582>
200020b2:	f853 2908 	ldr.w	r2, [r3], #-8
200020b6:	429a      	cmp	r2, r3
200020b8:	d0f5      	beq.n	200020a6 <_malloc_r+0x50e>
200020ba:	687b      	ldr	r3, [r7, #4]
200020bc:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
200020c0:	459c      	cmp	ip, r3
200020c2:	f63f ae8e 	bhi.w	20001de2 <_malloc_r+0x24a>
200020c6:	f1bc 0f00 	cmp.w	ip, #0
200020ca:	f43f ae8a 	beq.w	20001de2 <_malloc_r+0x24a>
200020ce:	ea1c 0f03 	tst.w	ip, r3
200020d2:	d027      	beq.n	20002124 <_malloc_r+0x58c>
200020d4:	46d6      	mov	lr, sl
200020d6:	e60e      	b.n	20001cf6 <_malloc_r+0x15e>
200020d8:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
200020dc:	d815      	bhi.n	2000210a <_malloc_r+0x572>
200020de:	ea4f 32dc 	mov.w	r2, ip, lsr #15
200020e2:	3277      	adds	r2, #119	; 0x77
200020e4:	ea4f 08c2 	mov.w	r8, r2, lsl #3
200020e8:	e749      	b.n	20001f7e <_malloc_r+0x3e6>
200020ea:	0508      	lsls	r0, r1, #20
200020ec:	0d00      	lsrs	r0, r0, #20
200020ee:	2800      	cmp	r0, #0
200020f0:	f47f aeb6 	bne.w	20001e60 <_malloc_r+0x2c8>
200020f4:	f8d7 8008 	ldr.w	r8, [r7, #8]
200020f8:	444b      	add	r3, r9
200020fa:	f043 0301 	orr.w	r3, r3, #1
200020fe:	f8c8 3004 	str.w	r3, [r8, #4]
20002102:	e700      	b.n	20001f06 <_malloc_r+0x36e>
20002104:	2101      	movs	r1, #1
20002106:	2500      	movs	r5, #0
20002108:	e6d5      	b.n	20001eb6 <_malloc_r+0x31e>
2000210a:	f240 5054 	movw	r0, #1364	; 0x554
2000210e:	4282      	cmp	r2, r0
20002110:	d90d      	bls.n	2000212e <_malloc_r+0x596>
20002112:	f44f 787c 	mov.w	r8, #1008	; 0x3f0
20002116:	227e      	movs	r2, #126	; 0x7e
20002118:	e731      	b.n	20001f7e <_malloc_r+0x3e6>
2000211a:	687b      	ldr	r3, [r7, #4]
2000211c:	ea23 030c 	bic.w	r3, r3, ip
20002120:	607b      	str	r3, [r7, #4]
20002122:	e7cb      	b.n	200020bc <_malloc_r+0x524>
20002124:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
20002128:	f10a 0a04 	add.w	sl, sl, #4
2000212c:	e7cf      	b.n	200020ce <_malloc_r+0x536>
2000212e:	ea4f 429c 	mov.w	r2, ip, lsr #18
20002132:	327c      	adds	r2, #124	; 0x7c
20002134:	ea4f 08c2 	mov.w	r8, r2, lsl #3
20002138:	e721      	b.n	20001f7e <_malloc_r+0x3e6>
2000213a:	bf00      	nop

2000213c <__malloc_lock>:
2000213c:	4770      	bx	lr
2000213e:	bf00      	nop

20002140 <__malloc_unlock>:
20002140:	4770      	bx	lr
20002142:	bf00      	nop

20002144 <_sbrk_r>:
20002144:	b538      	push	{r3, r4, r5, lr}
20002146:	f642 042c 	movw	r4, #10284	; 0x282c
2000214a:	f2c2 0400 	movt	r4, #8192	; 0x2000
2000214e:	4605      	mov	r5, r0
20002150:	4608      	mov	r0, r1
20002152:	2300      	movs	r3, #0
20002154:	6023      	str	r3, [r4, #0]
20002156:	f7fe faf5 	bl	20000744 <_sbrk>
2000215a:	f1b0 3fff 	cmp.w	r0, #4294967295
2000215e:	d000      	beq.n	20002162 <_sbrk_r+0x1e>
20002160:	bd38      	pop	{r3, r4, r5, pc}
20002162:	6823      	ldr	r3, [r4, #0]
20002164:	2b00      	cmp	r3, #0
20002166:	d0fb      	beq.n	20002160 <_sbrk_r+0x1c>
20002168:	602b      	str	r3, [r5, #0]
2000216a:	bd38      	pop	{r3, r4, r5, pc}
2000216c:	70616548 	.word	0x70616548
20002170:	646e6120 	.word	0x646e6120
20002174:	61747320 	.word	0x61747320
20002178:	63206b63 	.word	0x63206b63
2000217c:	696c6c6f 	.word	0x696c6c6f
20002180:	6e6f6973 	.word	0x6e6f6973
20002184:	0000000a 	.word	0x0000000a

20002188 <C.18.2576>:
20002188:	00000001 00000002 00000004 00000001     ................

20002198 <g_config_reg_lut>:
20002198:	40013000 40013004 40013008 4001300c     .0.@.0.@.0.@.0.@
200021a8:	40013010 40013014 40013018 4001301c     .0.@.0.@.0.@.0.@
200021b8:	40013020 40013024 40013028 4001302c      0.@$0.@(0.@,0.@
200021c8:	40013030 40013034 40013038 4001303c     00.@40.@80.@<0.@
200021d8:	40013040 40013044 40013048 4001304c     @0.@D0.@H0.@L0.@
200021e8:	40013050 40013054 40013058 4001305c     P0.@T0.@X0.@\0.@
200021f8:	40013060 40013064 40013068 4001306c     `0.@d0.@h0.@l0.@
20002208:	40013070 40013074 40013078 4001307c     p0.@t0.@x0.@|0.@

20002218 <g_gpio_irqn_lut>:
20002218:	00210020 00230022 00250024 00270026      .!.".#.$.%.&.'.
20002228:	00290028 002b002a 002d002c 002f002e     (.).*.+.,.-.../.
20002238:	00310030 00330032 00350034 00370036     0.1.2.3.4.5.6.7.
20002248:	00390038 003b003a 003d003c 003f003e     8.9.:.;.<.=.>.?.
20002258:	642f2e2e 65766972 6f632f72 755f6572     ../driver/core_u
20002268:	5f747261 2e627061 00000063              art_apb.c...

20002274 <_global_impure_ptr>:
20002274:	200022c4 00000043                       .". C...

2000227c <_init>:
2000227c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2000227e:	bf00      	nop
20002280:	bcf8      	pop	{r3, r4, r5, r6, r7}
20002282:	bc08      	pop	{r3}
20002284:	469e      	mov	lr, r3
20002286:	4770      	bx	lr

20002288 <_fini>:
20002288:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2000228a:	bf00      	nop
2000228c:	bcf8      	pop	{r3, r4, r5, r6, r7}
2000228e:	bc08      	pop	{r3}
20002290:	469e      	mov	lr, r3
20002292:	4770      	bx	lr

20002294 <__frame_dummy_init_array_entry>:
20002294:	0475 2000                                   u.. 

20002298 <__do_global_dtors_aux_fini_array_entry>:
20002298:	0461 2000                                   a.. 
